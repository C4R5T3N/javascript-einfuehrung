<!DOCTYPE html>
<html lang="de">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>JavaScript: Einbindung in HTML und Ereignisverarbeitung</title>
<link rel="stylesheet" href="js-doku.css">
<script type="text/javascript" src="js-doku.js"></script>
</head>
<body>

<div id="nav">
<p>Hier entsteht eine <strong>JavaScript-Dokumentation</strong> von <a href="http://molily.de/">molily</a>. Derzeit ist sie noch lückenhaft, wächst aber nach und nach. Kommentare und Feedback werden gerne per <a href="mailto:zapperlott@gmail.com">E-Mail</a> entgegen genommen.</p>
<p class="contents-link"><a href="./">Zum Inhaltsverzeichnis</a></p>
</div>

<h1>JavaScript: Einbindung in HTML und Ereignisverarbeitung</h1>

 <div class="section" id="ueber">
	<h2>Vorbemerkung</h2>
	<p>Von den vielen Möglichkeiten, JavaScript in HTML-Dokumente einzubetten, werden hier nur wenige gängige vorgestellt und empfohlen. Dieses Kapitel geht davon aus, dass HTML und JavaScript möglichst getrennt werden und sich JavaScripte eigenständig hinzuschalten. Die Hintergründe zu diesem Ansatz finden Sie im Kapitel <a href="hintergruende/einsatz.html">Sinnvoller JavaScript-Einsatz</a>.</p>
</div>
<div class="section" id="script-element">
	<h2>Das script-Element</h2>
	<p>Zur Einbindung von JavaScript-Code in HTML-Dokument existiert in das HTML-Element <code>script</code>. Dieses darf sowohl im Kopf (<code>head</code>-Element) als auch im Körper (<code>body</code>-Element) eines HTML-Dokuments auftauchen. Es kann entweder direkt JavaScript-Code beinhalten, wie in diesem Beispiel:</p>
	<pre>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Dokument mit integriertem JavaScript&lt;/title&gt;
&lt;script type="text/javascript"&gt;
window.alert("Hallo Welt!");
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Dokument mit integriertem JavaScript&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
	<p>Oder es kann leer sein und auf eine externe Datei mit JavaScript-Code verweisen. Diese Nutzungsweise sollten Sie vorziehen und Ihre JavaScripte möglichst in separate Dateien auslagern.</p>
	<p>Schreiben sie dazu Ihren JavaScript-Code in eine eigene Datei und speichern Sie sie mit der Dateiendung <code>.js</code> ab. Notieren Sie im Dokumentkopf ein <code>script</code>-Element, das den Browser auf die externe JavaScript-Datei hinweist. Dazu notieren Sie im <code>src</code>-Attribut die Adresse (URI), unter der das Script abrufbar ist. Vergessen Sie auch nicht das Attribut <code>type</code> mit dem festen Wert <code>text/javascript</code>. Dieses teilt dem Browser
	unmissverständlich mit, dass sie es sich bei ihrem Code um JavaScript handelt.</p>
	<pre>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Dokument mit externem JavaScript&lt;/title&gt;
&lt;script type="text/javascript" src="script.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Dokument mit externem JavaScript&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
	<p>In der Datei <var>script.js</var> können Sie nun JavaScript-Anweisungen, Funktionen, Objekte und so weiter notieren. Selbstverständlich können Sie mit dieser Methode mehrere Scripte einbinden: Verwenden Sie dazu einfach mehrere <code>script</code>-Elemente.</p>
	<p>Beachten Sie, dass diese eingebundenen Dateien direkt JavaScript-Code enthalten müssen. HTML-Code darf darin nicht vorkommen &ndash; in JavaScript-Strings ist er natürlich noch erlaubt. Insbesondere ist es nicht nötig, den JavaScript-Code in der separaten Datei noch einmal in ein <code>script</code>-Element zu verpacken. Dies würde dazu führen, dass der Browser den JavaScript-Code nicht korrekt ausführt.</p>
	<p>Ihre Scriptdateien können Sie &ndash; genauso wie Stylesheets, Grafiken usw. &ndash; auch in Unterverzeichnissen und sogar auf anderen Webservern unterbringen. Solange die angegebene URI korrekt ist, wird ein JavaScript-fähiger Browser sie beim Anzeigen des Dokuments herunterladen und ausführen.</p>
</div>
<div class="section" id="ausfuehrung">
	<h2>Ausführung von script-Elementen</h2>
	
	<p>Mit dem <code>script</code>-Element können Sie sowohl Scripte im Dokumentkopf als auch im Dokumentkörper einbetten. Die Ausführung des Scriptcodes läuft nach gewissen Regeln ab, die wir im folgenden betrachten.</p>
	<p>Die <code>script</code>-Elemente werden standardmäßig schon beim Einlesen des HTML-Dokuments ausgeführt. Das bedeutet: Wenn der Browser das HTML-Dokument vom Webserver empfängt, beginnt er sofort damit, den Quellcode zu verarbeiten und in eine interne Speicherstruktur, das <a href="dom.html">Document Object Model (DOM)</a> zu überführen. Das dafür zuständige Modul im Browser nennt sich <dfn>Parser</dfn> und der Verarbeitungsvorgang <dfn>Parsen</dfn>.</p>
	<p>Sobald der Parser auf ein <code>script</code>-Element trifft, wird das Parsing des HTML-Dokuments gestoppt und der JavaScript-Code wird ausgeführt. Dasselbe gilt für externe JavaScript-Dateien: Der Parser stoppt, lädt die externe JavaScript-Datei vom Webserver, führt diese aus und fährt erst dann mit der Verarbeitung des restlichen HTML-Quellcodes fort.</p>
	<p>Diese Vorgehensweise hat folgende Konsequenzen:</p>
	
	<div class="subsection" id="script-reihenfolge">
		<h3>Scripte haben Zugriff auf die Objekte vorher eingebundener Scripte</h3>
		<p>Die <code>script</code>-Elemente samt enthaltenem JavaScript-Code bzw. aus externen Dateien eingebundener JavaScript-Code werden in der Reihenfolge ausgeführt, in der sie im HTML-Quelltext notiert sind. Wenn Sie verschiedene Scripte haben, die aufeinander aufbauen, so müssen Sie sie nacheinander einbinden.</p>
			<pre>&lt;script type="text/javascript" src="grundlagenscript.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="aufbauscript.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
// Anwendung der Scripte
helferfunktion();
&lt;/script&gt;</pre>
		<p>Das Beispiel bindet drei Scripte ein, die ersten beiden als externe Dateien, das dritte direkt im HTML-Code. Da der Browser die Scripte in der Reihenfolge ihrer Einbindung ausführt, können spätere Scripte die Objekte, Funktionen und Variablen nutzen, die die vorher eingebundenen Scripte definiert haben. Im Beispiel wird zuerst <var>grundlagenscript.js</var> eingebunden, heruntergeladen und ausgeführt. Das darauffolgende Script aus der Datei <var>aufbauscript.js</var> kann die darin notierten Funktionen nutzen. Schließlich kann das dritte Script eine Funktion nutzen, die in <var>aufbauscript.js</var> definiert wurde.</p>
	</div>
	
	<div class="subsection" id="script-verzoegerung">
		<h3>Externe Scripte verzögern den Aufbau des Dokuments</h3>
		<p>Dass der Webbrowser die eingebundenen Scripte nicht erst <em>nach</em>, sondern bereits <em>während</em> dem Einlesen des HTML-Codes ausführt, hat Vor- und Nachteile. Einerseits werden Scripte so schnell wie möglich ausgeführt und es ist garantiert, dass ein externes Script ausgeführt wird, bevor ein nachfolgendes Script im Dokument abgearbeitet wird. Andererseits verlangsamt sich der Seitenaufbau, wenn große externe Scriptdateien vom Webserver heruntergeladen werden.</p>
		<p>Dieser Nachteil kann dadurch umgangen werden, alle <code>script</code>-Elemente in der notwendigen Reihenfolge am Dokument-Ende zu platzieren anstatt wie üblich in den Dokumentkopf. Aus Gründen der kürzeren Ladezeit und des schnelleren Aufbau des Dokumentes wird dies immer öfter empfohlen. Es setzt allerdings eine bestimmte Arbeitsweise voraus. Im Abschnitt <a href="#ereignisbasierung">Ereignisbasierte Scripte</a> werden wir eine Methode kennenlernen, bei die Scripte die Hauptarbeit erst verrichten, wenn das Dokument vollständig geladen wurde.</p>
	</div>
	
	<div class="subsection" id="script-document-write">
		<h3>Scripte können während des Ladens das Dokument mit <code>document.write</code> ergänzen</h3>
		<p>Mit der Methode <code>document.write</code> kann ein Script schon während dem Laden das Dokument direkt beeinflussen und einige Weichen stellen. <code>document.write</code> nimmt HTML-Code in einem JavaScript-String entgegen und fügt diesen an der Stelle ins Dokument ein, an denen das zugehörige <code>script</code>-Element steht.</p>
		<pre>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Zugriff auf das DOM während dem Parsen des Dokuments&lt;/title&gt;
&lt;script type="text/javascript"&gt;
document.write("&lt;link rel='stylesheet' href='javascript.css'&gt;");
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type="text/javascript"&gt;
document.write("&lt;p&gt;&lt;a href="javascript:location.reload()"&gt;Seite mittels JavaScript neu laden&lt;\/a&gt;&lt;\/p&gt;");
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
		<p>Das Beispiel enthält zwei Scripte mit <code>document.write</code>-Aufrufen. Diese schreiben HTML-Elemente ins Dokument, einmal ein Verweis auf ein Stylesheet und einmal ein Textabsatz mit einem JavaScript-Link.</p>
		<p><code>document.write</code> ist beim »Unobtrusive JavaScript« nur sehr selten sinnvoll. Inhalte, die nur bei aktiviertem JavaScript sichtbar sein sollen, da sie auf JavaScript-Funktionalität beruhen, sollten Sie ohne <code>document.write</code> dynamisch ins Dokument einfügen. Die dazu nötigen Techniken werden wir noch kennenlernen.</p>
		<p>Der Anwendungsbereich von <code>document.write</code> wird oftmals missverstanden. Wir haben hier den einen von zwei möglichen Anwendungsfällen kennenlernt: Das Ergänzen eines Dokuments noch während der Browser den HTML-Code einliest. Wenn <code>document.write</code> jedoch nach dem vollständigen Einlesen de HTML-Codes aufgerufen wird, die Methode einen ganz anderen Effekt und eignet sich nicht dazu, das vorhandene Dokument via JavaScript zu ändern.</p>
	</div>
	
	<div class="subsection" id="script-dom-zugriff">
		<h3>Ein Script hat Zugriff auf die Elemente vor dem zugehörigen <code>script</code>-Element</h3>
		<p>Wie Sie vielleicht wissen, ist die häufigste Aufgabe von JavaScripten der Zugriff auf das Dokument über die DOM-Schnittstelle, die die Elemente und deren Textinhalte als Knotenobjekte zugänglich macht. Doch weil ein Script mitten im Parsing-Prozess, also während des Einlesens des HTML-Dokuments ausgeführt wird, hat es zu diesem Zeitpunkt noch nicht Zugriff auf den gesamten DOM-Elementenbaum. Stattdessen kann es nur auf einen Teil-Baum zugreifen, genauer gesagt auf die Elemente, die vor dem zugehörigen <code>script</code>-Element liegen und somit vom Parser bereits verarbeitet wurden.</p>
		<pre>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Zugriff auf das DOM während dem Parsen des Dokuments&lt;/title&gt;
&lt;script type="text/javascript"&gt;
// Der Titel ist an dieser Stelle bereits verfügbar:
window.alert( document.title );
// Der Dokumentkörper allerdings noch nicht (ergibt null):
window.alert( document.body );
// Die Überschrift ebensowenig (ergibt null):
window.alert( document.getElementById("überschrift") );
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;script type="text/javascript"&gt;
window.alert( document.title ); // OK
// Der Dokumentkörper ist erst an dieser Stelle verfügbar:
window.alert( document.body );
// Die Überschrift allerdings noch nicht (ergibt null):
window.alert( document.getElementById("überschrift") );
&lt;/script&gt;

&lt;h1 id="überschrift"&gt;Beispielüberschrift&lt;/h1&gt;
&lt;script type="text/javascript"&gt;
window.alert( document.title ); // OK
window.alert( document.body ); // OK
// Die Überschrift ist erst an dieser Stelle verfügbar:
window.alert( document.getElementById("überschrift") );
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</pre>
		<p>Das Beispiel enthält drei Scripte, die jeweils versuchen, auf den Dokument-Titel (<code>title</code>-Element), den Dokument-Körper (<code>body</code>-Element) und eine Überschrift (<code>h1</code>-Element) zuzugreifen. Je nachdem, an welcher Stelle sich das Script und das angesprochene Element befinden, ist der Zugriff auf das Element möglich oder nicht. Der Zugriff funktioniert erst dann, wenn das anzusprechende Element dem jeweiligen Script vorangeht und bereits geparst wurde. Das Element muss dazu noch nicht abgeschlossen sein. Im Beispiel kann ein Script im <code>body</code>-Element bereits auf das geöffnete, aber noch nicht geschlossene <code>body</code>-Element zugreifen. Das Script hat jedoch nur Zugriff auf die vorherigen Geschwisterelemente (im Beispiel das <code>h1</code>-Element).</p>
		<p>Dies heißt nun nicht, dass sie zwangsläufig all ihre Scripte ans Dokumentende setzen müssen, damit ihr Script auf das gesamte Dokument zugreifen kann. Dieser Sachverhalt soll Ihnen nur die Ausgangssituation für ereignisbasierte Scripte schildern, die automatisch ihre Arbeit aufnehmen, sobald der gesamte HTML-Code geparst wurde und das Dokument fertig geladen ist.</p>
	</div>
</div>

<div class="section" id="noscript">
	<h2>Das <code>noscript</code>-Element</h2>
	<p>Das <code>noscript</code> ist als Gegenstück zu <code>script</code> gedacht: Damit lassen sich Alternativinhalte für Programme ins Dokument einfügen, die keine Scripte unterstützen. Browser, in denen JavaScripte deaktiviert oder nicht verfügbar ist, zeigen den Alternativinhalt an. Der Inhalt richtet sich auch an Programme wie Suchmaschinen-Robots, die das Dokument automatisiert verarbeiten, ohne die Scripte dabei zu beachten.</p>
	<pre>&lt;noscript&gt;
   &lt;p&gt;Dieser Absatz ist gehört zum Inhalt des Dokuments, ist aber im Browser nur zu sehen,
   wenn JavaScript deaktiviert oder nicht zur Verfügung steht.&lt;/p&gt;
&lt;/noscript&gt;</pre>
	<p>Der Sinn von <code>noscript</code> ist, die Informationen zugänglich zu machen, die sonst nur mithilfe des Scriptes zugänglich wären oder sogar durch das Script eingefügt werden. Diese Abwärtskompatibilität einer Website und die Zugänglichkeit aller Inhalte ohne JavaScript ist zwar erstrebenswert, allerdings zäumt »Unobtrusive JavaScript« das Pferd von vorne anstatt von hinten auf: Alle Informationen liegen bereits im Dokument und es ist auch ohne JavaScript gut bedienbar. Mittels JavaScript werden dann Zusatzfunktionen eingebaut, die die Bedienung und das Lesen der Inhalte vereinfachen und verbessern.</p>
	<p>Im Unobtrusive JavaScript kommt dem <code>noscript</code>-Element daher keine Bedeutung zu. Von seiner Verwendung wird sogar abgeraten, da es dazu verleitet, JavaScript-Logik mit dem HTML-Code fest zu verschweißen, anstatt diese sauber zu trennen. Gestalten Sie Ihre Website so, dass ohne JavaScript möglichst alle Inhalte zugänglich sind und alle Funktionen zur Verfügung stehen. Ihre JavaScripte schalten sich dann hinzu und modifizieren das Dokument entsprechend. Anstatt also mittels <code>noscript</code> ein Element einzufügen, das nur ohne JavaScript relevant ist, sollten Sie dieses ganz normal ohne <code>noscript</code> im Dokument notieren. Falls es bei aktiviertem JavaScript nicht benötigt wird, dann können Sie es mittels JavaScript verändern oder ganz ausblenden.</p>
	<p>Aus den besagten Gründen wird an dieser Stelle nicht näher auf <code>noscript</code> eingegangen &ndash; in den meisten Fällen werden Sie <code>noscript</code> nicht brauchen. Es gibt nur einige Spezialfälle, in denen <code>noscript</code> angemessen ist: Etwa wenn es sich bei der Website um eine reine JavaScript-Webanwendung handelt, die (noch) keine Alternativversion anbietet. Dann können Sie mit <code>noscript</code> einen Hinweis darauf hinterlegen, dass die Site einen JavaScript-fähigen Browser zwingend voraussetzt.</p>
</div>

<div class="section" id="ereignisbasierung">
	<h2>Ereignisbasierte Scripte</h2>
	<p>Der Abschnitt über die <a href="#ausfuehrung">Verarbeitung von Scripten</a> hat Ihnen gezeigt, dass der Browser Scripte üblicherweise in dem Moment ausführt, in dem er den Code eines HTML-Dokuments herunterlädt, parst und auf ein <code>script</code>-Element trifft.</p>
	<p>Der Schicksal von JavaScript ist aber nicht, bloß in diesem kurzen Moment des Ladens des HTML-Dokuments ausgeführt zu werden und dann für immer zur Ruhe zu kommen. Die meisten JavaScripte sollen Interaktivität bieten. Der Schlüssel dazu ist, das haben wir bereits in den <a href="http://redaktion.selfhtml.org/selfhtml-preview/javascript/konzepte.html#events">Grundkonzepten</a> kennengelernt, die <strong>Überwachung und Behandlung von Ereignissen</strong> (auch <strong>Event-Handling</strong> genannt).</p>
	<p>Moderne Scripte durchlaufen deshalb verschiedene <strong>Phasen</strong>:</p>
	<div class="subsection" id="phase-laden">
		<h3>1. Phase: Das Dokument wird geladen</h3>
		<p>Dabei wird das JavaScript ausgeführt. Variablen und Funktionen werden notiert, sodass sie für die spätere Nutzung zur Verfügung stehen. (Die notierten Funktionen werden dabei definiert, aber nicht notwendigerweise aufgerufen.) Wie gesagt hat das Script zu diesem Zeitpunkt noch keinen vollständigen Zugriff auf das Dokument.</p>
	</div>
	<div class="subsection" id="phase-onload">
		<h3>2. Phase: Das Dokument ist fertig geladen</h3>
		<p>Der vollständige Zugriff auf das Dokument über das DOM ist erst jetzt möglich. Nun wird ein Teil des Scripts aktiv, um dem bisher statischen Dokument JavaScript-Interaktivität hinzuzufügen: Das Script spricht vorhandene Elementknoten an und fügt ihnen sogenannte Event-Handler hinzu. Das Script kann aber auch den Inhalt oder die Darstellung von bestehenden Elementen verändern und dem Dokument neue Elemente hinzufügen (auch <strong>DOM-Manipulation</strong> genannt).</p>
	<div class="subsection" id="phase-event-handling">
		<h3>3. Phase: Der Anwender bedient das Dokument und das Script reagiert darauf</h3>
		<p>Wenn die überwachten Ereignisse an den entsprechenden Elementen im Dokument passieren, so werden gewisse andere Teiles des Scripts aktiv, denn die Handler-Funktionen werden ausgeführt.</p>
	</div>
	<div class="subsection" id="script-struktur">
		<h3>Resultierende Script-Struktur</h3>
		<p>Dieser chronologische Ablauf gibt die Struktur der meisten Scripte vor: Im Code werden vor allem mehrere Funktionen definiert, die später als <em>Handler</em> Ereignisse verarbeiten werden. Dann gibt es mindestens eine Hauptfunktion, die ausgeführt wird, wenn der Browser das Dokument fertig geladen hat, sodass Scripte darauf zugreifen können.</p>
		<p>Das erste und enorm wichtige Ereignis, mit dem wir uns beschäftigen müssen, ist daher das <code>load</code>-Ereignis. Es passiert aus JavaScript-Sicht im <a>Fenster</a> beim zugehörigen <code>window</code>-Objekt. Wenn dieses Ereignis eintritt, wird die zweite Phase aktiv. Dem JavaScript steht der gesamte DOM-Baum zur Verfügung, einzelne Elemente werden angesprochen und es werden Event-Handler registriert. Diese elementar wichtige Vorgehensweise bei der JavaScript-Programmierung wird uns nun beschäftigen.</p>
	</div>
</div>
<div class="section" id="traditionelles-event-handling">
	<h2>Traditionelles Event-Handling</h2>
	<p>Die Anweisung, die die Überwachung eines bestimmten Ereignisses an einem bestimmten Element startet, nennt man das <em>Registrieren</em> von Event-Handlern. Die drei nötigen Bestandteile (Elementobjekt, Ereignistyp und Handler-Funktion) finden wir in dem Aufbau der JavaScript-Anweisung wieder. Das Schema lautet allgemein:</p>
	<pre>element.onevent = handlerfunktion;</pre>
	<ul>
		<li><code>element</code> steht für ein JavaScript-Objekt, nämlich einen Elementknoten.</li>
		<li><code>onevent</code> ist eine Objekteigenschaft, die mit der Vorsilbe <code>on</code> beginnt, auf die der Ereignistyp folgt. <em>on</em> ist die englische Präposition für <em>bei</em>. Zum Beispiel <em>onclick</em> bedeutet soviel wie <em>beim Klicken</em>.</li>
		<li><code>handlerfunktion</code> ist der Name einer Funktion. Genauer gesagt steht an dieser Stelle ein beliebiger Ausdruck, der ein Funktionsobjekt ergibt.</li>
	</ul>
	<p>Insgesamt hat die Anweisung die Form »<em>Bei diesem Element: Beim Eintreten dieses Ereignisses führe diese Funktion aus.</em>«</p>
	<p>Der obige Pseudocode soll nur das allgemeine Schema illustrieren. Es gibt natürlich kein Ereignis namens <code>event</code> und <code>onevent</code> ist lediglich ein Platzhalter für alle möglichen Eigenschaften, darunter <code>onclick</code>, <code>onmouseover</code>, <code>onkeypress</code> und so weiter.</p>
	<p>Betrachten wir ein konkretes Beispiel. Wir wollen nach dem erfolgreichen Laden des Dokuments eine JavaScript-Funktion ausführen. Dazu haben wir bereits das <code>load</code>-Ereignis kennengelernt, dass beim <code>window</code>-Objekt passiert. Angenommen, wir haben eine Funktion namens <code>start</code> definiert:</p>
	<pre>function start () {
    window.alert("Dokument erfolgreich geladen! Wir können nun über das DOM darauf zugreifen.");
}</pre>
	<p>Gemäß dem obigen Schema starten wir folgendermaßen das Event-Handling:</p>
	<pre>window.onload = start;</pre>
	<p>Und schon wird die gezeigte Funktion beim erfolgreichen Laden des Dokuments ausgeführt.</p>
	<p>Sie werden sich sicher fragen, wie Ereignis-Verarbeitung auf JavaScript-Ebene funktioniert. Dazu schauen wir uns den Aufbau der besagten Anweisungen an: Wir haben dort eine einfache Wertzuweisung (erkennbar durch das <code>=</code>), die einer Objekteigenschaft (<code>window.onload</code> auf der linken Seite) einen Wert (<code>starte</code> auf der rechten Seite) zuweist. Nach dieser Zuweisung ist die Funktion in der Objekteigenschaft gespeichert. Dies funktioniert, weil Funktionen in JavaScripte auch nur Objekte sind, auf die beliebig viele Variablen und Eigenschaften verweisen können.</p>
	<p>Passiert nun ein Ereignis am Objekt <code>window</code>, sucht der JavaScript-Interpreter nach einer Objekteigenschaft, die den Namen <code>on</code> gefolgt vom Ereignistyp trägt (im Beispiel <code>onload</code>). Wenn diese Eigenschaft eine Funktion beinhaltet, führt er diese aus. Das ist erst einmal alles &ndash; aber enorm wichtig zum Verständnis des Event-Handlings.</p>
	<p>Wie Sie später erfahren werden, ist die oben vorgestellte Methode im Grunde überholt (siehe <a href="#traditionell-nachteile">Nachteile und Alternativen</a>). Dieses <em>traditionelle</em> Event-Handling ist aber immer noch der Ausgangspunkt jeder JavaScript-Programmierung. Sie sollten sich dieses Schema und dessen Funktionsweise genau einprägen.</p>
</div>
<div class="section" id="traditionelles-schema">
	<h2>Beispiel für traditionelles Event-Handling</h2>
	<p>Mit dem Wissen über Ereignis-Überwachung und das <code>load</code>-Ereignis können wir ein Dokument mitsamt eines Scriptes schreiben, das die <a href="#ereignisbasierung">beschriebenen drei Phasen</a> illustriert.</p>
	<pre>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Dokument mit JavaScript&lt;/title&gt;
&lt;script type="text/javascript"&gt; &hellip; &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;p id="interaktiv"&gt;Dies ist ein einfacher Textabsatz, aber mithilfe von JavaScript können wir
ihn interaktiv gestalten. Klicken Sie diesen Absatz doch einfach mal mit der Maus an!&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</pre>
	<p>Dem <code>p</code>-Element mit der ID <code>interaktiv</code> soll nun per JavaScript ein Event-Handler zugewiesen werden. Ziel ist, dass eine bestimmte JavaScript-Funktion aufgerufen wird, immer wenn der Anwender auf die Fläche des Element klickt. Das Ereignis, das bei einem Mausklick ausgelöst wird, heißt sinnigerweise <code>click</code>.</p>
	<p>Unser Script braucht drei Teile:</p>
	<ol>
		<li><strong>Warten, bis das Dokument vollständig geladen ist:</strong> Reagiere auf das <code>load</code>-Ereignis und führe eine Startfunktion aus, sobald das Ereignis passiert.</li>
		<li><strong>Einrichtung der Event-Handler:</strong> Die besagte Startfunktion spricht den Textabsatz an und registriert einen Event-Handler für das <code>click</code>-Ereignis.</li>
		<li><strong>Ereignis-Verarbeitung:</strong> Die Handler-Funktion, die beim Klick auf den Textabsatz ausgeführt wird.</li>
	</ol>
	<p>Teil 1 ist mit der Anweisung erledigt, die wir bereits oben kennengelernt haben:</p>
	<pre>window.onload = start;</pre>
	<p>Natürlich können wir der Startfunktion auch einen anderen Namen als <code>start</code> geben. Üblich ist z.B. <code>init</code>.</p>
	<p>Die Startfunktion für Teil 2 könnte so aussehen:</p>
<pre>function start () {
   document.getElementById("interaktiv").onclick = klickverarbeitung;
}</pre>
	<p>Was zunächst kompliziert aussieht, ist nichts anderes als die Anwendung des bekannten Schemas <code>element.onevent = handlerfunktion;</code>.</p>
	<p>Zur Einrichtung des Event-Handler greifen wir über das DOM auf das Dokument zu. Damit der Zugriff auf das gewünschte Element so einfach möglich ist, haben wir einen »Angriffspunkt« für das Script geschaffen, indem wir dem <code>p</code>-Element eine ID zugewiesen haben. Eine solche Auszeichnung über IDs und Klassen (<code>class</code>-Attribute) spielen eine wichtige Rolle, um Angriffspunkte für Stylesheets und Scripte zu bieten.</p>
	<p>Mit der DOM-Methode <code>document.getElementById</code> (zu deutsch: <em>gib mir das Element anhand der folgenden ID</em>) können wir das das Element mit der bekannten ID ansprechen. Der Aufruf <code>document.getElementById("interaktiv")</code> gibt uns das Objekt zurück, das das <code>p</code>-Element repräsentiert.</p>
	<p>Wir arbeiten direkt mit diesem Rückgabewert weiter und weisen dem Elementobjekt nun einen Event-Handler zu. Die Objekteigenschaft lautet <code>onclick</code>, denn es geht um das <code>click</code>-Ereignis. Die auszuführende Handler-Funktion lautet <code>klickverarbeitung</code>, dieser Name ist freilich willkürlich gewählt.</p>
	<p>Das ist schon alles und damit kommen wir zur Definition der besagten Funktion <code>klickverarbeitung</code>:</p>
	<pre>function klickverarbeitung () {
   document.getElementById("interaktiv").innerHTML += " Huhu, das ist von Javascript eingefügter Text.";
}</pre>
	<p>Was darin passiert, müssen Sie noch nicht bis ins Detail verstehen. Wie Sie sehen können, wird darin ebenfalls mittels <code>document.getElementById</code> das angeklickte <code>p</code>-Element angesprochen. Erneut wird eine Eigenschaft gesetzt, nämlich <code>innerHTML</code>. An den bestehenden Wert wird mit dem Operator <code>+=</code> ein String angehängt. Wenn Sie das Beispiel im Browser ausführen und auf das Element klicken, ändert sich der Text des Elements.</p>
	<p>Zusammengefasst sieht das Beispiel mit eingebettetem JavaScript so aus:</p>
	<pre>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Beispiel für traditionelles Event-Handling&lt;/title&gt;
&lt;script type="text/javascript"&gt;

window.onload = start;

function start () {
   document.getElementById("interaktiv").onclick = klickverarbeitung;
}

function klickverarbeitung () {
   document.getElementById("interaktiv").innerHTML += " Huhu, das ist von Javascript eingefügter Text.";
}

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;p id="interaktiv"&gt;Dies ist ein einfacher Textabsatz, aber mithilfe von JavaScript können wir ihn
interaktiv gestalten. Klicken Sie diesen Absatz doch einfach mal mit der Maus an!&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</pre>
	<p>Den JavaScript-Code können wir später natürlich in eine externe Datei auslagern.</p>
	<p>So einfach und nutzlos dieses kleine Beispiel aussieht: Wenn Sie dieses dreischrittige Schema verstanden haben, beherrschen Sie einen Großteil der JavaScript-Programmierung und wissen, wie Scripte üblicherweise strukturiert werden und schließlich ausgeführt werden.</p>
</div>
<div class="section" id="handler-loeschen">
	<h2>Event-Überwachung beenden</h2>
	<p>Wenn Sie einmal einen Event-Handler bei einem Element registriert haben, wird die Handler-Funktion künftig bei jedem Eintreten des Ereignisses ausgeführt &ndash; zumindest solange das Dokument im Browser dargestellt wird und es nicht neu geladen wird. Es ist möglich, die Event-Überwachung wieder mittels JavaScript zu beenden.</p>
	<p>Wie beschrieben besteht das traditionelle Event-Handling schlicht darin, dass eine Objekteigenschaft (z.B. <code>onclick</code>) durch eine Wertzuweisung mit einer Funktion gefüllt wird. Um das Registrieren des Handlers rückgängig zu machen, beschreiben wir erneut diese Objekteigenschaft. Allerdings weisen wir ihr keine Funktion zu, sondern einen anderen Wert. Dazu bietet sich beispielsweise der spezielle Wert <code>null</code> an, der soviel wie »absichtlich leer« bedeutet.</p>
	<p>Das Schema zum Löschen des Event-Handlers lautet demnach:</p>
	<pre>element.onevent = null;</pre>
	<p>Wenn wir im obigen Beispiel die Überwachung des Klick-Ereignisses beim <code>p</code>-Element wieder beenden wollen, können wir entsprechend notieren:</p>
	<pre>document.getElementById("interaktiv").onclick = null;</pre>
</div>

<div class="section" id="fehler-handler-aufrufen">
	<h2>Häufiger Fehler: Handler-Funktion direkt aufrufen</h2>
	<p>Ein häufiger Fehler beim Registrierens eines Event-Handlers sieht folgendermaßen aus:</p>
	<pre>element.onevent = handlerfunktion();   // Fehler!</pre>
	<p>Oft steckt hinter dieser Schreibweise der Wunsch, der Handler-Funktion noch Parameter mitzugeben, damit darin gewissen Daten zur Verfügung stehen:</p>
	<pre>element.onevent = handlerfunktion(parameter);   // Fehler!</pre>
	<p>Sie müssen sich die Funktionsweise des traditionellen Event-Handlings noch einmal durch den Kopf gehen lassen, um zu verstehen, warum diese Anweisungen nicht den gewünschten Zweck erfüllen. Beim korrekten Schema <code>element.onevent = handlerfunktion;</code> wird eine Funktion, genauer gesagt ein Funktionsobjekt, in einer Eigenschaft des Elementobjektes gespeichert.</p>
	<p>Das ist beim obigen Code nicht der Fall. Stattdessen wird die Handler-Funktion wegen den Klammern <code>()</code> hinter dem Funktionsnamen <strong>sofort ausgeführt</strong>. Diese Klammern sind nämlich der sogenannte Aufruf-Operator.</p>
	<p>Das Erste, was der JavaScript-Interpreter beim Verarbeiten dieser Zeile macht, ist der Aufruf der Funktion. Deren <em>Rückgabewert</em> wird schließlich in der <code>onevent</code>-Eigenschaft gespeichert. In den meisten Fällen hat die Handler-Funktion keinen Rückgabewert, was dem Wert <code>undefined</code> entspricht, oder sie gibt <code>false</code> zurück, sodass schlicht diese Werte in die Eigenschaft geschrieben werden. Wir wollen die Funktion aber nicht direkt aufrufen, sondern bloß das Funktionsobjekt ansprechen, um es in die Eigenschaft zu kopieren. Daher dürfen an dieser Stelle keine Klammern hinter dem Namen notiert werden.</p>
	<p>Der Wunsch, der Handler-Funktion gewisse Daten als Parameter zu übergeben, ist verständlich. Die obige fehlerhafte Schreibweise vermag dies aber nicht zu leisten. Leider ist diese Aufgabenstellung auch nicht so einfach lösbar: Das altbekannte Schema <code>element.onevent = handlerfunktion;</code> muss eingehalten werden. Der Funktionsaufruf, der die Parameter übergibt, wird in einer zusätzlichen Funktion untergebracht (gekapselt). Schematisch:</p>
	<pre>function helferfunktion (parameter) {
   /* Arbeite mit dem Parameter und verarbeite das Ereignis */
}
function handlerfunktion () {
   helferfunktion("Parameter");
}
element.onevent = handlerfunktion;</pre>
	<p>Das konkrete Beispiel aus dem vorigen Abschnitt können wir so anpassen, dass in der Handler-Funktion bloß eine andere Hilfsfunktion mit Parametern ausgeführt wird:</p>
	<pre>window.onload = start;

function start () {
   document.getElementById("interaktiv").onclick = klickverarbeitung;
}

function klickverarbeitung () {
   textHinzufügen(document.getElementById("interaktiv"), "Huhu, das ist von Javascript eingefügter Text.");
}

function textHinzufügen (element, neuerText) {
   element.innerHTML += neuerText;
}
</pre>
	<p>In der Handler-Funktion <code>klickverarbeitung</code> wird die neue Funktion <code>textHinzufügen</code> mit Parametern aufgerufen. Diese wurde verallgemeinert und ist wiederverwendbar: Sie nimmt zwei Parameter an, einmal ein Elementobjekt und einmal einen String. Die Funktion hängt sie den angegebenen Text in das angegebene Element ein.</p>
</div>
<div class="section" id="inline-handler">
	<h2>Eingebettete Event-Handler-Attribute</h2>
	<p>Wir haben kennengelernt, wie wir externe JavaScripte einbinden und darin auf »traditionelle« Weise Event-Handler registrieren können. Der Vorteil davon ist, dass wir HTML- und JavaScript-Code und damit das Dokument und das JavaScript-Verhalten trennen können.</p>
	<p>Wann immer es möglich ist, sollten Sie diese Vorgehensweise des »Unobtrusive JavaScript« wählen. Es soll aber nicht verschwiegen werden, dass es auch möglich ist, JavaScript direkt im HTML-Code unterzubringen und damit auf Ereignisse zu reagieren.</p>
	<p>Zu diesem Zweck besitzen fast alle HTML-Elemente entsprechende Attribute, in die Sie den auszuführenden JavaScript-Code direkt hineinschreiben können. In diesem Code können Sie natürlich auch eigene Funktionen aufrufen, die sie in einem <code>script</code>-Element oder einer externen JavaScript-Datei definiert haben. Die Attribute sind genauso benannt wie die entsprechenden JavaScript-Eigenschaften: Die Vorsilbe <code>on</code> gefolgt vom Ereignistyp (z.B. <code>click</code>). Das
	Schema lautet dementsprechend:</p>
	<pre>&lt;element onevent="JavaScript-Anweisungen"&gt;</pre>
	<p>Ein konkretes Beispiel:</p>
	<pre>&lt;p onclick="window.alert('Absatz wurde geklickt!');"&gt;Klicken Sie diesen Textabsatz an!&lt;/p&gt;</pre>
	<p>Hier enthält das Attribut die JavaScript-Anweisung <code>window.alert('Absatz wurde geklickt!');</code>, also einen Aufruf der Funktion <code>window.alert</code>. Sie können mehrere Anweisungen in einer Zeile notieren, indem Sie sie wie üblich mit einem Semikolon trennen. Zum Beispiel Funktionsaufrufe:</p>
	<pre>&lt;p onclick="funktion1(); funktion2();"&gt;Klicken Sie diesen Textabsatz an!&lt;/p&gt;</pre>
	<p>Wie sie sehen, wird es hier schon unübersichtlich. Sie müssen Ihren Code in eine Zeile quetschen, damit die Browser das Attribut korrekt verarbeiten.</p>
	<p>Es gibt viele gute Gründe, HTML und JavaScript möglichst zu trennen und auf solches <em>Inline-JavaScript</em> zu verzichten. Natürlich hat diese Grundregel berechtigte Ausnahmen. Als Anfänger sollten sie sich jedoch mit der Trennung sowie dem Registrieren von Event-Handlern mittels JavaScript vertraut machen, wie es in den vorigen Abschnitten erläutert wurde. Wenn Ihre Scripte komplexer werden, werden Sie vielleicht vereinzelt auf Event-Handler-Attribute zurückgreifen, aber der Großteil sollte ohne sie funktionieren.</p>
	<p>Die Verwendung von solchen Event-Handler-Attrbuten bringt viele Eigenheiten und Nachteile mit sich, auf die an dieser Stelle nicht weiter eingegangen wird.</p>
	<p>(Zugriff auf this u.d. Event-Objekt, Mehrere Anweisungen und Whitespace, Stringbegrenzung/Anführungszeichen, geänderte Scope-Chain, siehe Forumsposting)</p>
</div>
<div class="section" id="fehler-code-als-string">
	<h2>Häufiger Fehler: Auszuführenden Code als String zuweisen</h2>
	<p>Nachdem wir Inline-JavaScript angeschnitten haben, sei auf einen weiteren häufigen Fehler beim traditionellen Event-Handling hingewiesen. Manche JavaScript-Programmierer übertragen ihr Wissen über Event-Handler-Attribute intuitiv auf das das dynamische Setzen von Event-Handlern. Sie versuchen z.B. folgendes:</p>
	<pre>element.onclick = "window.alert('Element wurde geklickt!');"</pre>
	<p>Oder gleichwertig mithilfe der DOM-Methode <code>setAttribute</code>:</p>
	<pre>element.setAttribute("onclick", "window.alert('Element wurde geklickt!');");</pre>
	<p>Sprich, sie behandeln die Eigenschaft <code>onclick</code> und dergleichen wie Attribute unter vielen. Für viele andere Attribute gilt das auch. Ein Beispiel:</p>
	<pre>&lt;p&gt;&lt;a id="link" href="http://de.selfhtml.org/"
   title="Deutschsprachige Anleitung zum Erstellen von Webseiten"&gt;SELFHTML&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;
var element = document.getElementById("link");
element.title = "Die freie Enzyklopädie";
element.href = "http://de.wikipedia.org/";
element.firstChild.nodeValue = "Wikipedia";
&lt;/script&gt;</pre>
	<p>Das Script spricht ein Link-Element über seine ID an und ändert dessen Attribute <code>title</code> und <code>href</code> sowie schließlich dessen Textinhalt. Das Beispiel illustriert, dass sich die Zuweisungen der Attributwerte im HTML und im JavaScript stark ähneln. Die neuen Attributwerte werden im JavaScript einfach als Strings notiert.</p>
	<p>Diese Vorgehensweise ist beim Setzen von Event-Handler-Attributen über JavaScript nicht völlig falsch. <em>Theoretisch</em> haben folgende Schreibweisen denselben Effekt:</p>
	<pre>// Methode 1: Traditionelles Event-Handling
function handlerfunktion () {
   window.alert("Hallo Welt!");
}
element.onevent = handlerfunktion;

// Methode 2: Auszuführenden Code als als String zuweisen
// (Achtung, nicht browserübergreifend!)
element.setAttribute("onevent", "window.alert('Hallo Welt!');");</pre>
	<p>Ihnen mag die die zweite Schreibweise in vielen Fällen einfacher und kürzer erscheinen. Doch zum einen hat sie das Problem, dass sie in der Praxis längst nicht so etabliert ist wie die traditionelle: Der Internet Explorer einschließlich der neuesten Version 8 unterstützt diese Schreibweise noch nicht.</p>
	<p>Davon abgesehen hat es Nachteile, JavaScript-Code nicht in Funktionen zu ordnen, sondern in Strings zu verpacken. Der Code wird unübersichtlicher und Fehler sind schwieriger zu finden. Sie sollten daher möglichst das traditionelle Schema vorziehen.</p>
</div>
<div class="section" id="event-objekt">
	<h2>Zugriff auf das Event-Objekt</h2>
	<p>Durch das Registrieren von Event-Handlern wird die angegebene Funktion immer dann ausgeführt, wenn das jeweilige Ereignis beim jeweiligen Element eintritt. In dieser Handler-Funktion ist es meistens nötig, auf die näheren Umstände des Ereignisses zu reagieren. Beispielsweise sind bei einem Mausklick die Koordinaten des Mauszeigers interessant oder bei einem Tastendruck die gedrückte Taste.</p>
	<p>All diese Informationen sind in JavaScript beim <strong>Event-Objekt</strong> gespeichert. Dieses Objekt repräsentiert das individuelle Ereignis, das der Handler gerade verarbeitet. Es bietet zahlreiche Eigenschaften mit Informationen zum Ereignis und einige Methoden, um das Verhalten des Ereignisses zu steuern. Wenn Sie bei der Ereignisverarbeitung diese Daten benötigen, ist der Zugriff auf das Event-Objekt die erste Aufgabe in der Handler-Funktion.</p>
	<p>In den meisten Browsern gestaltet sich dieser Zugriff einfach: Das Event-Objekt wird der Handlerfunktion automatisch als erster Parameter übergeben. Sie muss dieses nur noch entgegen nehmen, der Parametername ist dabei frei wählbar. Üblicherweise wird ein Kurzname wie <code>e</code> oder <code>ev</code> verwendet. Für das folgende Beispiel wählen wir den sprechenden Namen <code>eventObjekt</code>:</p>
	<pre>function handlerfunktion (eventObjekt) {
   window.alert("Es ist ein Ereignis vom Typ " + eventObjekt.type + " passiert.");
   // Fehler im Internet Explorer!
}</pre>
	<p>Diesen Zugriff auf das Event-Objekt unterstützen alle relevanten Browser außer dem Internet Explorer. Für den IE ist eine Sonderlösung notwendig. Er übergibt das Event-Objekt nicht als Parameter an die Handlerfunktion, sondern stellt es unter dem globalen Objekt <code>window.event</code> zur Verfügung. Auch wenn es den Anschein hat: Dort ist das Event-Objekt nicht dauerhaft gespeichert, sondern <code>window.event</code> verweist lediglich auf das jeweilige Event-Objekt des Ereignisses, das gerade im jeweiligen Handler verarbeitet wird.</p>
	<p>Um browserübergreifend auf das Event-Objekt zuzugreifen, ist also eine Vereinheitlichung notwendig. Diese ist recht einfach: Wir prüfen, ob der Funktion ein Parameter übergeben wurde und somit die lokale Variable <code>eventObjekt</code> einen Wert hat. Falls dies zutrifft, nehmen wir diesen Parameter als Event-Objekt. Andernfalls speichern wir in der bisher leeren Variable eine Referenz auf <code>window.event</code>.</p>
	<pre>function handlerfunktion (eventObjekt) {
   // Vereinheitlichung:
   if (!eventObjekt) {
      // Korrektur für den Internet Explorer
      eventObjekt = window.event;
   }

   // Browserübergreifender Zugriff:
   window.alert("Es ist ein Ereignis vom Typ " + eventObjekt.type + " passiert.");
}</pre>
	<p>Nach der Vereinheitlichung steht das Event-Objekt browserübergreifend in einer Variable zu Verfügung.</p>
	<p>Mit <code>if (!eventObjekt)</code> wird geprüft, ob der Wert der Variablen bei einer Umwandlung in den Typ Boolean den Wert <code>false</code> ergibt. Eine solche Abfrage ist hier möglich, weil <code>eventObjekt</code> entweder ein Objekt enthält oder, falls der Handlerfunktion nichts übergeben wird, mit dem Wert <code>undefined</code> initialisiert wird. Dieser ergibt in Boolean umgewandelt <code>false</code>.</p>
	<p>Eine gleichwertige alternative Schreibweise nutzt den <code>||</code>-Operator. Intern funktioniert diese wie die besagte <code>if</code>-Anweisung : Es wird geprüft, ob ein Funktionsparameter übergeben wurde. Falls nicht, wird versucht, das Event-Objekt über <code>window.event</code> anzusprechen. Das Ziel ist ebenfalls vereinheitlichter Zugriff auf das Event-Objekt über die Variable <code>eventObjekt</code>.</p>
	<pre>function handlerfunktion (eventObjekt) {
   eventObjekt = eventObjekt || window.event;
   window.alert("Es ist ein Ereignis vom Typ " + eventObjekt.type + " passiert.");
}</pre>
	<p>Der Oder-Operator <code>||</code> überprüft, ob der Wert links <code>true</code> ergibt, also der Parameter <code>eventObjekt</code> gesetzt wurde. Wenn dies der Fall ist, ergibt der Ausdruck den Wert von <code>eventObjekt</code> und es wird quasi <code>eventObjekt = eventObjekt</code> ausgeführt. Dabei passiert selbstverständlich nichts, die Variable wird mit sich selbst überschrieben.</p>
	<p>Interessant ist der andere Fall, wenn <code>eventObjekt</code> im Internet Explorer den Wert <code>undefined</code> hat (siehe oben). Dann ergibt der Ausdruck den Wert rechts vom <code>||</code>-Operator und es wird <code>eventObjekt = window.event</code> ausgeführt. Durch diese Oder-Verzweigung ist das Event-Objekt in jedem Fall in der Variable <code>eventObjekt</code> gespeichert.</p>
	<p>Welche der funktional identischen Schreibweise Sie verwenden, bleibt ihnen überlassen. Die erste ist klarer und leicht verständlich, die zweite ist kürzer, erfordert jedoch das Verständnis des <code>||</code>-Operators.</p>
	<p>In den obigen Beispielen wird das Event-Objekt in der Variable mit dem sprechenden Namen <code>eventObjekt</code> gespeichert. Die Namenswahl bleibt selbstverständlich Ihnen überlassen. Es hat sich eingebürgert, diese Variable der Kürze halber <code>e</code> zu nennen, um Tipparbeit zu sparen. Wenn in einer Handler-Funktion eine Variable <code>e</code> auftaucht, dann ist darin in der Regel das Event-Objekt gespeichert. Sie könnten gleichermaßen schreiben:</p>
	<pre>function handlerfunktion (e) {
   e = e || window.event;
   window.alert("Es ist ein Ereignis vom Typ " + e.type + " passiert.");
}</pre>
</div>
<div class="section" id="standardaktion">
	<h2>Unterdrücken der Standardaktion des Ereignisses</h2>
	<p>Viele Ereignisse im Dokument haben eigentümliche Auswirkungen. Ein Beispiel: Wenn der Anwender auf einen Link klickt, so tritt ein <code>click</code>-Ereignis ein. Das bringt den Browser dazu, dem Link zu folgen und zum angegebenen Linkziel (der URI) zu navigieren. Das bedeutet, dass der Browser die Ressource vom Webserver herunterlädt und anzeigt. Ein weiteres Beispiel: Das Aktivieren eines Absende-Buttons eines Formulars löst ein <code>submit</code>-Ereignis aus, das zur Übertragung des Formulars an den Webserver führt.</p>
	<p>Der Browser behandelt also standardmäßig gewisse Ereignisse und führt die sogenannte <strong>Standardaktion</strong> (englisch <em>default action</em>) aus, ohne dass der Seitenautor eine entsprechende JavaScript-Logik definiert hat.</p>
	<p>Beim Unobtrusive JavaScript versieht man z.B. bestehende Hyperlinks mit einer JavaScript-Logik. Die ursprüngliche Funktionalität des Links will man dann zumeist unterbinden: Beim Klick auf den Link soll nur das Script ausgeführt werden, nicht mehr das Linkziel angesprungen werden.</p>
	<p>Angenommen, wir haben folgenden Link:</p>
	<pre>&lt;a href="bilder/bild.jpg" id="vollbildlink"&gt;Bild in Originalgröße ansehen&lt;/a&gt;</pre>
	<p>Mit JavaScript soll diesem Link nun ein <code>click</code>-Handler hinzugefügt werden, der das verlinkte Bild im aktuellen Dokument einblendet, anstatt das Dokument durch das Bild auszuwechseln und das Bild einzeln anzuzeigen. Wie dieses Einblenden umgesetzt wird, interessiert uns an dieser Stelle nicht, sondern nur das Unterdrücken der Standardaktion.</p>
	<p>Im traditionellen Event-Handling wird die Standardaktion unterdrückt, indem die Handler-Funktion <code>false</code> als Ergebnis zurückgibt. Am Ende der Funktion wird daher die Anweisung <code>return false;</code> notiert.</p>
	<pre>function zeigeVollbild () {
   // Blende das Bild ein, auf das der Link zeigt.
   // ... (an dieser Stelle uninteressant) ...

   // Unterdrücke schließlich die Standardaktion:
   return false;
}

// Registriere Event-Handler
document.getElementById("vollbildlink").onclick = zeigeVollbild;
</pre>
	<p>Beachten Sie, dass mit der <code>return</code>-Anweisung die Funktion beendet wird. Code, der auf diese Anweisung folgt, wird nicht ausgeführt. Es sei denn, die <code>return</code>-Anweisung ist z.B. durch eine <code>if</code>-Anweisung gekapselt und wird nicht in jedem Fall ausgeführt.</p>
	<p>Wenn Sie kein <code>return false</code> notieren, führt der Browser automatisch die Standardaktion aus. Sie müssen ihn also nicht mit einem <code>return true</code> oder auf andere Art dazu bringen &ndash; sie können die Standardaktion lediglich verhindern.</p>
	<p>Neben <code>return false</code> gibt es modernere Techniken, um die Standardaktion zu verhindern. Der DOM-Standard, auf den wir später noch zu sprechen kommen, bietet eine Methode namens <code>preventDefault</code> beim Event-Objekt, mit der sich die Standardaktion unterdrücken lässt. Das obige Beispiel könnte auch folgendermaßen aussehen:</p>
	<pre>function zeigeVollbild (eventObjekt) {
   // Browserübergreifender Zugriff auf das Event-Objekt
   if (!eventObjekt) eventObjekt = window.event;

   // Unterdrücke die Standardaktion durch Aufruf von preventDefault:
   e.preventDefault();
   // Fehler im Internet Explorer!

   // Blende das Bild ein, auf das der Link zeigt.
   // ... (an dieser Stelle uninteressant) ...
};</pre>
	<p>Der Vorteil von <code>preventDefault</code> ist, dass es im Gegensatz zu <code>return false</code> auch mitten in der Handler-Funktion aufgerufen werden kann, ohne sie gleichzeitig zu beenden. Das Beispiel demonstriert dies.</p>
	<p>Der Nachteil ist, dass der Internet Explorer diese standardisierte Methode noch nicht kennt. Er hat jedoch eine Boolean-Eigenschaft des Event-Objekts namens <code>returnValue</code>. Weist man dieser den Wert <code>false</code> zu, so wird die Standardaktion unterbunden. Um alle Browser zu unterstützen, kann die Existenz der <code>preventDefault</code>-Methode abgefragt werden. Existiert diese nicht, wird alternativ die Eigenschaft <code>returnValue</code> gesetzt:</p>
	<pre>function zeigeVollbild (eventObjekt) {
   if (!eventObjekt) eventObjekt = window.event;

   // Existiert die Methode preventDefault? Dann rufe sie auf.
   if (eventObjekt.preventDefault) {
      eventObjekt.preventDefault();
   } else {
      // Andernfalls setze returnValue für den Internet Explorer
      eventObjekt.returnValue = false;
   }

   // Blende das Bild ein, auf das der Link zeigt.
   // ... (an dieser Stelle uninteressant) ...
};</pre>
	<p>Diese Vorgehensweise sei hier der Vollständigkeit halber erwähnt. Wenn sie Ihnen unnötig kompliziert erscheint, so können Sie sich mit dem herkömmlichen <code>return false</code> zufrieden geben, das die Aufgabe hinreichend erfüllt. Sie müssen allerdings beachten, dass mit <code>return false</code> die Handler-Funktion beendet wird.</p>
	<!-- <note editor="molily" type="question">An einigen Stellen bin ich im IE mit return false nicht weitergekommen und musste returnValue = false setzen. Muss untersucht werden, ob return false wirklich preventDefault und returnValue ersetzen kann</note> -->
</div>
<div class="section" id="bubbling">
	<h2>Der Event-Fluss: Bubbling</h2>
	<p>Bisher haben wir erfahren, dass Ereignisse bei bestimmten Elementen passieren. Dort können wir sie überwachen, indem wir Handler registrieren. Tritt das Ereignis bei diesem Element ein, wird die Handler-Funktion ausgelöst.</p>
	<p>Die Wirklichkeit ist etwas komplizierter. Die Verarbeitung eines Ereignisses verläuft, in drei verschiedenen Phasen, die nacheinander durchlaufen werden. Davon kennen wir bereits eine und werden nun eine zweite kennenlernen. Die dritte ist weniger wichtig und braucht Sie beim Einstieg in das Event-Handling erst einmal nicht interessieren &ndash; sie finden Sie unter <a href="#capturing">Capturing</a> beschrieben.</p>
	<p>Ein Ereignis passiert bei einem Element, dem sogenannten <strong>Zielelement</strong> (englisch <em>target element</em>), und löst dort alle Handler aus, die für das entsprechende Ereignis registriert wurden &ndash; soweit waren wir bereits. Diese bereits bekannte Phase nennt sich entsprechend <strong>Ziel-Phase</strong>.</p>
	<p>Mit dieser Phase ist die Ereignis-Verarbeitung nicht zuende, denn anschließend steigt das Ereignis im DOM-Elementenbaum auf. Dieser Vorgang nennt sich <strong>Bubbling</strong> (englisch für Aufsteigen, wie z.B. Luftblasen im Wasser). Dieses Aufsteigen bedeutet, dass die entsprechenden Handler auch beim Eltern-Element des Zielelements ausgeführt werden, dann bei dessen Eltern-Element und so weiter, bis das Ereignis schließlich den obersten <code>document</code>-Knoten erreicht hat.
	Das Ereignis bewegt sich also nach oben im Elementbaum, durchläuft alle Vorfahrenelemente des Zielelements und löst auf diesem Weg alle entsprechenden Handler aus. Dieser Vorgang wird entsprechend <strong>Bubbling-Phase</strong> genannt.</p>
	<p>Das mag für den Anfang unverständlich klingen, der Sinn und die Funktionsweise des Bubblings sind aber schnell erfasst. Nehmen wir folgenden HTML-Code:</p>
	<pre>&lt;p id="absatz"&gt;
   Dies ist ein Beispiel-Element mit einem
   &lt;strong id="wichtig"&gt;
      wichtigen Text
   &lt;/strong&gt;.
&lt;/p&gt;</pre>
	<p>Nehmen wir ferner an, dass das <code>p</code>-Element einen <code>click</code>-Handler bekommt:</p>
	<pre>function klickverarbeitung () {
   window.alert("Der Absatz wurde geklickt!");
}
document.getElementById("absatz").onclick = klickverarbeitung;</pre>
	<p>Das <code>p</code>-Element wird vom Browser als rechteckige Box dargestellt. Bei einem Klick irgendwo in diese Box soll die Handler-Funktion ausgeführt werden.</p>
	<p>Wenn der Anwender auf das Wort »Beispiel-Element« klickt, ist das <code>p</code>-Element das Zielelement des Ereignisses. Wenn man hingegen auf »wichtigen Text« klickt, so ist das <code>strong</code>-Element das Zielelement des Ereignisses, nicht das p-Element! Denn dieser Text liegt in erster Linie im <code>strong</code>-Element und nur indirekt im <code>p</code>-Element. Aus Sicht des DOM-Baumes ist der Text ein Textknoten, der ein Kindknoten des <code>strong</code>-Elementknotens ist.</p>
	<p>Nichtsdestoweniger erwartet man, dass ein Klick auf die Box des <code>strong</code>-Elements ebenfalls den <code>click</code>-Handler beim <code>p</code>-Element auslöst. Und dies ist auch der Fall &ndash; dafür sorgt das Bubbling! Das Ereignis, das ursprünglich beim <code>strong</code>-Element passiert ist, steigt nämlich auf, sodass der Handler des <code>p</code>-Elements ausgeführt wird.</p>
	<p>Das Bubbling ist also meist erwünscht, damit bei einem Element Ereignisse überwacht werden können, selbst wenn sie ursprünglich bei Kindelementen passieren. Wenn Sie aber nicht damit rechnen, dass Ereignisse aufsteigen, so kann das Bubbling zu einiger Verwirrung führen und Sie werden sich wundern, woher plötzlich gewisse Ereignisse stammen.</p>
	<p>Nicht alle Ereignisse steigen auf, denn für manche Ereignisse wäre es kontraproduktiv, wenn sie zentrale Handler auslösen würden.</p>
</div>
<div class="section" id="currenttarget-target">
	<h2>Verarbeitendes Element und Zielelement</h2>
	<p>Durch das beschriebene Bubbling ist es möglich, das sich das Element, bei dem ein Ereignis ursprünglich passiert ist, von dem unterscheiden kann, dessen Handler gerade aufgerufen wird. Es ist möglich, dass das Element, das das Ereignis verarbeitet, im DOM-Elementenbaum oberhalb vom Zielelement liegt. Das Ereignis steigt in dem Fall vom Zielelement auf und löst bei einem anderen Element die Handler-Funktion aus.</p>
	<p>In vielen Fällen will man in der Handler-Funktion auf beide beteiligten Elemente zugreifen, sofern sie sich unterscheiden.</p>
	<p>Beginnen wir mit dem Zugriff auf das <strong>verarbeitende Element</strong>, bei dem die Handler-Funktion registriert wurde: Das Element kann in der Handler-Funktion über das Schlüsselwort <code>this</code> angesprochen werden, denn die Handler-Funktion wird im Kontext dieses Elementobjektes ausgeführt.</p>
	<p>Das obige Beispiel wird wieder aufgegriffen:</p>
	<pre>&lt;p id="absatz"&gt;
   Dies ist ein Beispiel-Element mit einem
   &lt;strong id="wichtig"&gt;
         wichtigen Text
   &lt;/strong&gt;.
&lt;/p&gt;</pre>
	<p>Dem Absatz wird wieder ein <code>click</code>-Handler zugewiesen:</p>
	<pre>function klickverarbeitung () {
   window.alert("Element vom Typ " + this.nodeName + " wurde geklickt!");
}
document.getElementById("absatz").onclick = klickverarbeitung;</pre>
	<p>Innerhalb der Handler-Funktion können wir über <code>this</code> auf das <code>p</code>-Element zugreifen. Im Beispiel wird auf dessen Eigenschaft <code>nodeName</code> ausgegeben, welche den Elementnamen <code>P</code> enthält.</p>
	<p>Der DOM-Standard sieht eine andere Zugriffsweise vor: Die Eigenschaft <code>currentTarget</code> beim Event-Objekt enthält das Element, dessen Handler gerade ausgeführt wird. Der Internet Explorer kennt diese Eigenschaft noch nicht und das besagte <code>this</code> ist im IE die einzige Möglichkeit, auf das fragliche Element zuzugreifen. Der Einfachheit halber können Sie daher browserübergreifend <code>this</code> verwenden.</p>
	<p>[interaktives Beispiel, das den Unterschied der beiden Elemente illustriert]</p>
	<p>Der eindeutige Zugriff auf das <strong>Zielelement</strong> gestaltet sich etwas schwieriger. Der DOM-Standard definiert die Eigenschaft <code>target</code> beim Event-Objekt. Alleinig der Internet Explorer unterstützt diese Eigenschaft nicht, kennt aber eine äquivalente Eigenschaft namens <code>srcElement</code>. Mithilfe einer Fähigkeitenweiche nehmen wir eine Vereinheitlichung vor, sodass das Zielelement in allen Browsern über eine Variable ansprechbar ist &ndash; wir kennen dieses Prozedere bereits vom Zugriff auf das Event-Objekt.</p>
	<pre>function klickverarbeitung (eventObjekt) {
   if (!eventObjekt) eventObjekt = window.event;

   if (eventObjekt.target) {
      var target = eventObjekt.target;
   } else {
      var target = eventObject.srcElement;
   }

   window.alert(
      "Das Ereignis passierte ursprünglich beim Element " + target.nodeName +
      " und wird vom Element " + this.nodeName + " verarbeitet.");
   );
}</pre>
	<p>Falls die Eigenschaft <code>target</code> des Event-Objektes gefüllt ist, legen wir in der lokalen Variable <code>target</code> eine Referenz darauf an. Andernfalls, das betrifft den Internet Explorer, wird die Eigenschaft <code>srcElement</code> verwendet.</p>
	<p>Wie beim Zugriff auf das Event-Objekt erlaubt der <code>||</code>-Operator eine Kurzschreibweise. Das Event-Objekt wird zudem unter dem Kurznamen <code>e</code> gespeichert. So kommen wir zu einem Schema, dem viele Handler-Funktionen entsprechen:</p>
	<pre>function klickverarbeitung (e) {
   // Vereinheitlichung von Event-Objekt und Zielelement
   e = e || window.event;
   var target = e.target || e.srcElement;

   // Nutzlast
   window.alert(
      "Das Ereignis passierte ursprünglich beim Element " + target.nodeName +
      " und wird vom Element " + this.nodeName + " verarbeitet.");
   );
}</pre>
</div>
<div class="section" id="bubbling-verhindern">
	<h2>Kontrolle über den Event-Fluss: Bubbling verhindern</h2>
	<p>Es gibt Fälle, in denen das Bubbling nicht gewünscht ist. Beispielsweise wenn zwei verschachtelte Elemente dasselbe Ereignis überwachen, aber nur der Handler des inneren Elements aktiv werden soll, wenn dieses das Ziel des Ereignisses ist. In einer Handler-Funktion können Sie deshalb das weitere Aufsteigen des Ereignisses im Elementenbaum verhindern.</p>
	<p>Folgendes bekannte Beispiel mit verschachtelten Elementen soll dies illustrieren:</p>
	<pre>&lt;p id="absatz"&gt;
   Dies ist ein Beispiel-Element mit einem
   &lt;strong id="wichtig"&gt;
      wichtigen Text
   &lt;/strong&gt;.
&lt;/p&gt;</pre>
	<p>Das <code>strong</code>-Element steckt hier im <code>p</code>-Element. Bei beiden Elementen wird ein <code>click</code>-Handler registriert:</p>
	<pre>function absatzKlick () {
   window.alert("Klick auf das p-Element");
}
document.getElementById("absatz").onclick = absatzKlick;

function wichtigKlick () {
   window.alert("Klick auf das strong-Element");
}
document.getElementById("wichtig").onclick = wichtigKlick;</pre>
	<p>Bei einem Klick auf die Fläche des <code>strong</code>-Elements (»wichtigen Text«) werden beide Handler-Funktionen ausgeführt, denn das Ereignis steigt vom <code>strong</code>-Element zum <code>p</code>-Element auf.</p>
	<p>Dieses Aufsteigen können Sie in der Handler-Funktion des <code>strong</code>-Elementes (<code>wichtigKlick</code>) verhindern. Der DOM-Standard definiert dafür die Methode <code>stopPropagation</code> (englisch: stoppe die Ausbreitung bzw. Weitergabe des Ereignisses) beim Event-Objekt. Ein Aufruf dieser Methode unterbricht den Event-Fluss und verhindert damit das (weitere) Aufsteigen.</p>
	<p>Der Internet Explorer kennt diese Methode nicht, verfügt jedoch über eine gleichwertige Boolean-Eigenschaft beim Event-Objekt. Diese trägt den Namen <code>cancelBubble</code> (englisch: breche das Aufsteigen ab). Weisen Sie dieser Eigenschaft den Wert <code>true</code> zu, um das Aufsteigen des Ereignisses abzubrechen.</p>
	<p>Wieder einmal nutzen wir eine Fähigkeitenerkennung, die die Verfügbarkeit der standardisierten Methode <code>stopPropagation</code> prüft und im Fehlerfalle auf die Internet-Explorer-Alternative <code>cancelBubble</code> zurückfällt.</p>
	<p>Die Handler-Funktion <code>wichtigKlick</code> wird wie folgt modifiziert:</p>
	<pre>function wichtigKlick (eventObekt) {
   if (!eventObjekt) eventObjekt = window.event;

   if (eventObjekt.stopPropagation) {
      eventObjekt.stopPropagation();
   } else {
      eventObjekt.cancelBubble = true;
  }

   window.alert("Klick auf das strong-Element. Das Aufsteigen des Ereignisses wird unterbunden!");
}</pre>
	<p>Damit können verschachtelte Elemente denselben Ereignistyp überwachen, im Beispiel <code>click</code>. Obwohl das eine Element in dem anderen enthalten ist und üblicherweise in dessen Grenzen dargestellt wird, übernimmt es die Ereignis-Verarbeitung selbstständig. Der Handler des äußeren Elements, im Beispiel <code>absatzKlick</code> beim <code>p</code>-Element, wird nur bei Klicks ausgeführt, die auf seine Fläche zielen, ausgenommen die Fläche des inneren Elements.</p>
</div>
<div class="section" id="traditionell-nachteile">
	<h2>Nachteile des traditionellen Event-Handlings und Alternativen</h2>
	<p>Das traditionelle Event-Handling basiert darauf, dass ein Funktionsobjekt in einer Eigenschaft des Elementobjektes gespeichert wird. Wir erinnern uns an das Schema <code>element.onevent = handlerfunktion</code>.</p>
	<p>Der Vorteil dieses Schema ist seine Einfachheit und Verständlichkeit. Will man ein Ereignis überwachen, schreibt man bloß die Handler-Funktion in eine entsprechende Element-Eigenschaft. Der größte Nachteile ist jedoch folgender: Es kann nur <em>eine</em> Handler-Funktion zugleich registriert werden. Denn in der Eigenschaft kann nur eine Funktion gespeichert werden, und weist man eine andere Funktion zu, überschreibt man die erste.</p>
	<p>In manchen Fällen mag es ausreichen, dass man je Element für einen Ereignistyp nur eine Handlerfunktion definieren kann. Diese kann schließlich weitere Funktionen aufrufen, sodass nicht der gesamte auszuführende Code direkt in dieser einen Funktion stehen muss. Doch insbesondere wenn verschiedene Scripte zusammenarbeiten, besteht die Gefahr, dass sie beim traditionellen Event-Handling einander in die Quere kommen.</p>
	<p>Es ist es durchaus möglich, mehrere Handler-Funktionen zu notieren, ohne letztlich vom traditionellen Schema abzuweichen. Dazu sind allerdings Helferscripte nötig, deren Funktionsweise nur für erfahrene JavaScript-Kenner zu verstehen ist: Sie erzeugen immer neue Funktionen, die die bestehende Handler-Funktion und die neue, zusätzliche Handler-Funktion einschließen. Man spricht von sogenannten <em>Wrapper-Funktionen</em> (englisch: Hülle, Umschlag).</p>
	<p>Bevor wir auf solche »Workarounds« eingehen, wenden wir uns den fortgeschrittenen Modellen für Event-Handling zu.</p>
</div>
<div class="section" id="dom-events">
	<h2>Event-Handling gemäß dem W3C-Standard DOM Events</h2>
	<p>Das bisher beschriebene traditionelle Schema stammt aus den Anfangstagen von JavaScript. Der Browserhersteller und JavaScript-Erfinder Netscape erfand das Schema einst und andere Browser übernahmen es im Zuge ihrer JavaScript-Unterstützung.</p>
	<p>Die Entwicklung ging jedoch weiter: Bei der Standardisierung des Event-Handlings verwarf das WWW-Konsortium das traditionelle Event-Handling. Der entsprechende DOM-Standard sieht ein anderes Modell vor: Alle Elementobjekte und weitere zentrale Objekte besitzen die Methode <code>addEventListener</code> (englisch: Ereignis-Empfänger hinzufügen). Will man dem Element einen Event-Handler zuweisen, so ruft man diese Methode auf.</p>
	<div class="subsection" id="addEventListener">
		<h3>Event-Handler registrieren: <code>addEventListener</code></h3>
		<p>Das standardisierte Schema enthält ebenfalls die drei Bestandteile Elementobjekt, Ereignistyp und Handler-Funktion. Es lautet folgendermaßen:</p>
		<pre>element.addEventListener("event", handlerfunktion, capturing);</pre>
		<p>Die Methode erwartet also drei Parameter:</p>
		<ol>
			<li>Der erste Parameter ist ein String und enthält den <strong>Ereignistyp</strong>. Beispiele für den ersten Parameter sind <code>"click"</code>, <code>"mouseover"</code>, <code>"load"</code>, <code>"submit"</code> und so weiter.</li>
			<li>Der zweite Parameter ist der Name der <strong>Handler-Funktion</strong>, genauer gesagt ein Ausdruck, der ein Funktionsobjekt ergibt.</li>
			<li>Der dritte Parameter bestimmt, für welche <strong>Event-Phase</strong> der Handler registriert werden soll. Es handelt sich um einen Boolean-Parameter, d.h. sie können <code>true</code> oder <code>false</code> notieren. <code>false</code> steht für die bereits bekannte Bubbling-Phase, <code>true</code> für die noch nicht behandelte und weniger wichtige <em>Capturing-Phase</em> (siehe <a href="capturing">Capturing</a>). Die genaue Bedeutung des dritten
			Parameters wird erst später erklärt werden. Standardmäßig sollten Sie hier <code>false</code> notieren.</li>
		</ol>
		<p>Das folgende Beispiel kennen wir bereits vom traditionellen Event-Handling. Beim fertigen Laden des HTML-Dokuments wird automatisch ein <code>click</code>-Handler bei einem Textabsatz registriert. Dieses Mal nutzen wir die standardisierte Methode <code>addEventListener</code>, die denselben Zweck erfüllt:</p>
		<pre>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Beispiel für Event-Handling gemäß dem W3C DOM&lt;/title&gt;
&lt;script type="text/javascript"&gt;

window.addEventListener("load", start, false);

function start () {
   var pElement = document.getElementById("interaktiv");
   pElement.addEventListener("click", klickverarbeitung, false);
}

function klickverarbeitung () {
   document.getElementById("interaktiv").innerHTML += " Huhu, das ist von Javascript eingefügter Text.";
}

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;p id="interaktiv"&gt;Dies ist ein einfacher Textabsatz, aber mithilfe von JavaScript können wir ihn
interaktiv gestalten. Klicken Sie diesen Absatz doch einfach mal mit der Maus an!&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</pre>
		<p>Folgende Anweisungen haben sich geändert:</p>
		<p>Aus der Zuweisung <code>window.onload = start;</code> ist der Aufruf <code>window.addEventListener("load", start, false);</code> geworden. Auch wenn <code>window</code> kein Elementobjekt ist, bietet es auch die Methode <code>addEventListener</code> an.</p>
		<p>Aus der Zuweisung <code>document.getElementById("interaktiv").onclick = klickverarbeitung;</code> sind zwei geworden. In der ersten Anweisung speichern wir das Elementobjekt des Absatzes in einer Variable zwischen:</p>
		<pre>var pElement = document.getElementById("interaktiv");</pre>
		<p>In der zweiten Anweisung wird schließlich die Handler-Funktion registriert:</p>
		<pre>pElement.addEventListener("click", klickverarbeitung, false);</pre>
		<p>Sie können die Methoden-Aufrufe natürlich auch verketten, anstatt eine Hilfsvariable zu verwenden. Das sähe schematisch so aus: <code>document.getElementById(&hellip;).addEventListener(&hellip;)</code>. Schließlich gibt <code>getElementById</code> im Regelfall ein Elementobjekt zurück, dessen Methoden Sie direkt ansprechen können. Aus Gründen der Lesbarkeit und Verständlichkeit wurde diese Kette im Beispiel in zwei Anweisungen gesplittet.</p>
		<p>Das obige Beispiel funktioniert in allen modernen Browsern &ndash; außer dem Internet Explorer. Dieser unterstützt den W3C-DOM-Standard noch nicht, wie wir schon von diversen Eigenschaften und Methoden des Event-Objektes wissen. Die Methode <code>addEventListener</code> ist ihm schlicht unbekannt.</p>
		<p>Im Gegensatz zum traditionellen Event-Handling wird <code>addEventListener</code> daher nicht browserübergreifend unterstützt. Der Internet Explorer unterstützt stattdessen ein <a href="#microsoft">eigenes, proprietäres Modell</a>, das im folgenden Abschnitt vorgestellt wird.</p>
		<p>Der Hauptvorteil von <code>addEventListener</code> ist, dass Sie für ein Element <strong>mehrere Handler-Funktionen</strong> für denselben Ereignistyp registrieren können. Beim obigen Beispiel können wir die <code>start</code>-Funktion so anpassen, dass beim <code>p</code>-Element zwei Handler statt bloß einer registriert werden:</p>
		<pre>function start () {
   var pElement = document.getElementById("interaktiv");
   pElement.addEventListener("click", meldung1, false);
   pElement.addEventListener("click", meldung2, false);
}

function meldung1 () {
   window.alert("Erste Handler-Funktion ausgeführt!");
}

function meldung2 () {
   window.alert("Zweite Handler-Funktion ausgeführt!");
}</pre>
		<p>Es werden zwei Handler-Funktionen namens <code>meldung1</code> und <code>meldung2</code> definiert. Mithilfe von <code>addEventListener</code> werden sie beide als <code>click</code>-Handler registriert. Wenn Sie auf den Textabsatz klicken, dann sollten nacheinander zwei JavaScript-Meldefenster erscheinen &ndash; und zwar in der Reihenfolge, in der die Handler mittels <code>addEventListener</code> registriert wurden.</p>
	</div>
	<div class="subsection" id="removeEventListener">
		<h3>Event-Handler entfernen: removeEventListener</h3>
		<p>Um die mit <code>addEventListener</code> registrierten Handler wieder zu <strong>entfernen</strong>, gibt es die Schwestermethode <code>removeEventListener</code> (englisch: Ereignis-Empfänger entfernen). Die Methode erwartet dieselben Parameter, die <code>addEventListener</code> beim Registrieren bekommen hat: Einen String mit dem Ereignistyp, die zu löschende Handler-Funktion und schließlich einen Boolean-Wert für die Event-Phase.</p>
		<p>Um beide im Beispiel definierten Handler für das <code>p</code>-Element (nämlich <code>meldung1</code> und <code>meldung2</code>) wieder zu entfernen, notieren wir:</p>
		<pre>function beenden () {
   pElement.removeEventListener("click", meldung1, false);
   pElement.removeEventListener("click", meldung2, false);
}</pre>
	</div>
</div>
<div class="section" id="microsoft">
	<h2>Event-Handling gemäß Microsoft</h2>
	<p>Microsoft hat schon früh für seinen Internet Explorer eine Alternative zum unzureichenden traditionellen Event-Handling eingeführt, welches vom damaligen Konkurrenten Netscape erfunden wurde. Das W3C-DOM wurde erst später standardisiert und wird bis heute nicht vom Internet Explorer unterstützt. Das Microsoft-Modell wiederum wird nur vom Internet Explorer verstanden. Es handelt sich hier also um eine Sonderlösung, die nur interessant ist, weil der Internet Explorer den DOM-Standard
	noch nicht umsetzt.</p>
	<p>Microsofts Modell teilt einige Fähigkeiten mit <code>addEventListener</code> und <code>removeEventListener</code>, funktioniert im Detail jedoch anders und bringt einige Eigenheiten und Schwierigkeiten mit sich.</p>
	<div class="subsection" id="attachEvent">
		<h3>Event-Handler registrieren: attachEvent</h3>
		<p>Im Microsoft-Modell besitzt jedes Elementobjekt sowie einige zentrale Objekte die Methode <code>attachEvent</code> zum Registrieren von Event-Handlern. Das Schema lautet folgendermaßen:</p>
		<pre>element.attachEvent("onevent", handlerfunktion);</pre>
		<p>Die Methode erwartet zwei Parameter:</p>
		<ol>
			<li>Der erste Parameter ist ein String und enthält den <strong>Ereignistyp</strong> mit der Vorsilbe <code>on</code>. Beispiele für den ersten Parameter sind <code>"onclick"</code>, <code>"onmouseover"</code>, <code>"onload"</code>, <code>"onsubmit"</code> und so weiter.</li>
			<li>Der zweite Parameter ist der Name der <strong>Handler-Funktion</strong> (ein Ausdruck, der ein Funktionsobjekt ergibt).</li>
		</ol>
		<p>Wir greifen das bekannte Beispiel auf, das wir bereits nach dem traditionellem Modell und nach dem W3C-Modell umgesetzt haben, und setzen es mit dem Microsoft-Modell um:</p>
		<pre>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Beispiel für Event-Handling gemäß dem W3C DOM&lt;/title&gt;
&lt;script type="text/javascript"&gt;

window.attachEvent("onload", start);

function start () {
   var pElement = document.getElementById("interaktiv");
   pElement.attachEvent("onclick", klickverarbeitung);
}

function klickverarbeitung () {
   document.getElementById("interaktiv").innerHTML += " Huhu, das ist von Javascript eingefügter Text.";
}

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;p id="interaktiv"&gt;Dies ist ein einfacher Textabsatz, aber mithilfe von JavaScript können wir ihn
interaktiv gestalten. Klicken Sie diesen Absatz doch einfach mal mit der Maus an!&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</pre>
		<p>Das Beispiel hat sich gegenüber dem W3C-Modell nur geringfügig geändert. Anstelle von <code>window.addEventListener(&hellip;)</code> wurde <code>window.attachEvent(&hellip;)</code> notiert, dasselbe bei <code>pElement.attachEvent(&hellip;)</code>.</p>
		<p>Der Ereignistyp im ersten Parameter enthält nun den Präfix <code>on</code> vorangestellt: Aus <code>"load"</code> wird <code>"onload"</code>, aus <code>"click"</code> wird <code>"onclick"</code>. Der dritte Parameter, der die Event-Phase spezifiert, fällt weg &ndash; denn Microsofts Modell unterstützt nur das Registrieren in der Bubbling-Phase.</p>
		<p>Auch mit <code>attachEvent</code> können Sie verschiedene Handler für denselben Ereignistyp definieren. Das obige Beispiel wird entsprechend angepasst:</p>
		<pre>function start () {
   var pElement = document.getElementById("interaktiv");
   pElement.attachEvent("onclick", meldung1);
   pElement.attachEvent("onclick", meldung2);
}

function meldung1 () {
   window.alert("Erste Handler-Funktion ausgeführt!");
}

function meldung2 () {
   window.alert("Zweite Handler-Funktion ausgeführt!");
}</pre>
		<p>Das Beispiel enthält nichts neues, die Aufrufe von <code>addEventListener</code> wurden auf die besagte Weise durch <code>attachEvent</code> ausgetauscht.</p>
	</div>
	<div class="subsection" id="detachEvent">
		<h3>Event-Handler entfernen: detachEvent</h3>
		<p>Auch das Microsoft-Modell bietet eine Methode, um registrierte Handler wieder zu entfernen. Sie nennt sich <code>detachEvent</code> und erwartet dieselben Parameter wie sein Gegenstück <code>attachEvent</code>.</p>
		<p>Um die besagten <code>click</code>-Handler <code>meldung1</code> und <code>meldung2</code> wieder zu entfernen, notieren wir:</p>
		<pre>function beenden () {
   pElement.detachEvent("onclick", meldung1);
   pElement.detachEvent("onclick", meldung2);
}</pre>
	</div>
	<div class="subsection">
		<h2>Eigenheiten des Microsoft-Modell</h2>
		<p>Das Microsoft-Modell bringt ein eine erfreuliche und eine unerfreuliche Besonderheit mit sich:</p>
		<ul>
			<li>Bei der Verwendung von <code>attachEvent</code> gestaltet sich der <a href="#event-objekt">Zugriff auf das Event-Objekt</a> einfacher, als wir es vom traditionellen Event-Handling gewöhnt sind. Dort war der Zugriff über <code>window.event</code> nötig. Bei der Benutzung von <code>attachEvent</code> wird das Event-Objekt der Handler-Funktion als Parameter übergeben, wie wir es aus anderen Browsern gewohnt sind und wie es auch beim im DOM-Standard vorgeschrieben ist.</li>
			<li>Der Zugriff auf das verarbeitende Element ist nicht möglich. Beim traditionellen Event-Handling hatten wir <code>this</code> kennengelernt, um das Element anzusprechen, bei dem die gerade ausgeführte Handler-Funktion registriert wurde. Das ist im Zusammenhang mit <code>attachEvent</code> nicht möglich, denn <code>this</code> zeigt nicht auf das gewünschte Objekt, sondern stets auf das globale Objekt <code>window</code> &ndash; und ist damit unbrauchbar.</li>
			<li>Im Gegensatz zum DOM-Standard kennt das Microsoft-Modell keine Capturing-Phase.</li>
		</ul>
	</div>
</div>
<div class="section" id="addevent">
	<h2>Browserübergreifendes Event-Handling</h2>
	
	<div class="subsection" id="addevent-lage">
		<h3>Ausgangslage</h3>
		<p>Wir haben drei Modelle und deren Detailunterschiede kennengelernt. Das mag Sie verwirrt haben und Sie werden sich sicher fragen, welches Sie nun in der Praxis ohne Bedenken anwenden können. Das Fazit lautet leider: Keines.</p>
		<ul>
			<li>Das traditionelle Event-Handling reicht in einfachen Fällen aus, Sie werden aber sehr schnell an dessen Grenzen stoßen.</li>
			<li>DOM Events ist zweifelsohne das leistungsfähigste und vielseitigste, der gravierende Nachteil ist jedoch, dass der weit verbreitete Internet Explorer den W3C-Standard noch nicht umsetzt.</li>
			<li>Das Microsoft-Modell kann zwar als Ausweichlösung für den Internet Explorer verwendet werden. Es bringt jedoch starke Einschränkungen mit sich, die einer Korrektur bedürfen, und manche unüberbrückbaren Unterschiede führen dazu, dass es nicht gleichwertig zum W3C-Modell eingesetzt werden kann.</li>
		</ul>
	</div>
	
	<div class="subsection" id="addevent-helfer">
		<h3><code>addEvent</code>-Helferfunktionen</h3>
		<p>Um relativ komfortabel browserübergreifend Ereignisse verarbeiten zu können, benötigen wir eine Helferfunktion, die eine Vereinheitlichung vornimmt und gewisse Browserunterschiede nivelliert. Eine solche alleinstehende Funktion zum Registrieren von Event-Handlern wird in der Regel <code>addEvent</code> genannt</p>
		<p>Die Entwicklung einer solchen <code>addEvent</code>-Funktion ist eine Wissenschaft für sich. Moderne <a href="">JavaScript-Bibliotheken</a> nutzen äußerst ausgefeilte Umsetzungen. Diese basieren auf jahrelanger Forschung, um viele Sonderfälle abzudecken und dem Anwender das Event-Handling durch Vereinheitlichung sämtlicher Browserunterschiede zu vereinfachen.</p>
		<p>Diese Bibliotheken bringen jedoch eine komplett neue und eigene Arbeitsweise sowie unzählige weitere Funktionen mit sich und erschlagen den Nutzer damit förmlich. Daher seien hier zwei isolierte Helferscripte vorgestellt.</p>
	</div>

	<div class="subsection">
		<h3 id="einfaches-addevent">Einfaches, oftmals ausreichendes <code>addEvent</code></h3>
		<p>Ein einfaches Beispiel ist <a href="http://www.ilfilosofo.com/blog/2008/04/14/addevent-preserving-this/">A Good Enough addEvent</a> von Austin Matzko. Ziel ist es, mehrere Event-Handler für einen Typ bei einem Element registrieren zu können. Die Funktion verwendet <code>addEventListener</code> (DOM-Standard) oder <code>attachEvent</code> (Microsoft-Modell) je nach Verfügbarkeit.</p>
<pre>function addEvent (obj, type, fn) {
   if (obj.addEventListener) {
      obj.addEventListener(type, fn, false);
   } else if (obj.attachEvent) {
      obj.attachEvent('on' + type, function () {
         return fn.call(obj, window.event);
      });
   }
}</pre>
		<p>Ein Anwendungsbeispiel:</p>
		<pre>&lt;p id="beispielabsatz"&gt;Klick mich!&lt;/p&gt;
&lt;script type="text/javascript"&gt;
	function absatzKlick () {
		alert("Der Absatz wurde geklickt!");
	}
	addEvent(document.getElementById("beispielabsatz"), "click", absatzKlick);
&lt;/script&gt;</pre>
		<p>Da die beiden Modelle im Detail zueinander inkompatibel sind, sind im <code>attachEvent</code>-Zweig einige Anpassungen vonnöten. Die übergebene Handler-Funktion wird in einer weiteren gekapselt und eingeschlossen, die an deren Stelle als Handlerfunktion verwendet wird.</p>
		<ol>
			<li>Der Kontext wird der Handler-Funktion korrigiert. Dadurch ist in der Handler-Funktion mittels <code>this</code> der Zugriff auf das verarbeitende Element möglich. (Siehe <a href="#currenttarget-target">verarbeitendes Element</a>.)</li>
			<li>Der Handler-Funktion wird das Event-Objekt als Parameter übergeben. Dadurch fällt in der Handler-Funktion die Vereinheitlichung bem Zugriff darauf weg. (Siehe <a href="#event-objekt">Zugriff auf das Event-Objekt</a>.)</li>
		</ol>
		<p>Diese Funktion ist wie gesagt sehr einfach gehalten, was unter anderem folgende Nachteile mit sich bringt:</p>
		<ul>
			<li>Es gibt keine äquivalente Funktion zum Entfernen eines Event-Handlers (<code>removeEvent</code>).</li>
			<li>Wenn Sie dieselbe Handler-Funktion für einen Ereignistyp beim selben Element mehrfach registrieren, verhält sich der Internet Explorer anders als die restlichen Browser, die den DOM-Standard unterstützen: Die Handler-Funktion wird nur einmal ausgeführt anstatt so oft, wie Sie den Handler registriert haben. Diese Fall ist allerdings vermeidbar, in der Regel besteht keine Notwendigkeit, einen Handler mehrfach zu registrieren.</li>
			<li>Es werden nur die allerwichtigsten Browserunterschiede vereinheitlicht, auf viele weitere müssen Sie in der Handler-Funktion selbst reagieren.</li>
		</ul>
	</div>
	
	<div class="subsection" id="flexibles-addevent">
		<h3>Flexibles und leistungsfähiges <code>addEvent</code>/<code>removeEvent</code></h3>
		<p>Eine robustere, aber umso kompliziertere Lösung, die diee Funktionen <code>addEvent</code> und <code>removeEvent</code> bietet, stammt von Dean Edwards und wurde von Tino Zijdel weiterentwickelt: <a href="http://therealcrisp.xs4all.nl/upload/addEvent_dean.html">addEvent() new style</a></p>
		<p>Dieses Helferscript verwendet die standardisierte Methoden <code>addEventListener</code> und <code>removeEventListener</code> in den Browsern, in denen sie zur Verfügung stehen. Als Alternative für den Internet Explorer wird allerdings nicht das Microsoft-eigene Modell verwendet &ndash; zu groß sind die Unterschiede zwischen den beiden Modellen. Stattdessen wird das Registrieren von mehreren Event-Handlern selbst übernommen: Es wird bei jedem Element eine eigene Liste mit Handler-Funktionen für ein Ereignistyp geführt. Beim Eintreten des Ereignisses wird eine Helferfunktion aufgerufen, die diese interne Liste abarbeitet und jede dort verzeichnete Handler-Funktion aufruft.</p>
		<p>Neben <code>addEvent</code> umfasst das Script auch eine <code>removeEvent</code>-Methode. Im Vergleich zum einfachen <code>addEvent</code> werden im Internet Explorer zwei weitere Vereinheitlichungen vorgenommen.</p>
		<ol>
			<li>In der Handler-Funktion ist mittels <code>this</code> der Zugriff auf das verarbeitende Element möglich. (Siehe <a href="#currenttarget-target">verarbeitendes Element</a>.)</li>
			<li>Der Handler-Funktion wird das Event-Objekt als Parameter übergeben. (Siehe <a href="#event-objekt">Zugriff auf das Event-Objekt</a>.)</li>
			<li>Zum Unterdrücken der Standardaktion kann browserübergreifend die standardisierte Methode <code>preventDefault</code> des Event-Objektes verwendet werden. Eine entsprechende Fähigkeiten-Weiche in der Handler-Funktion ist nicht nötig. (Siehe <a href="#standardaktion">Unterdrücken der Standardaktion</a>.)</li>
			<li>Um das Aufsteigen des Ereignisses zu verhindern, kann die standardisierte Methode <code>stopPropagation</code> des Event-Objektes browserübergreifend genutzt werden. (Siehe <a href="#bubbling-verhindern">Bubbling verhindern</a>.)</li>
		</ol>
		<p>...</p>
	</div>
	
	<div class="subsection" id="addevent-frameworks">
		<h3>Browserübergreifendes Event-Handling mit Frameworks</h3>
		<p> Die besagte Browser-Vereinheitlichung berührt nur die Spitze des Eisberges: Besonders bei der Verarbeitung von Tastatur- und Maus-Ereignissen erwarten den JavaScript-Programmierer noch viel größere Browserunterschiede. Um beispielsweise browserübergreifend die Mausposition relativ zum Dokument auszulesen, ist eine komplexe Fähigkeiten-Weiche nötig. Dasselbe gilt für das Auslesen der gedrückten Taste(n). Für den JavaScript-Einsteiger ist es schwierig und unkomfortabel, für all diese Detailunterschiede Korrekturen einzubauen. Das eigentliche Verarbeiten der Ereignisse rückt durch dieses Browser-Durcheinander (im Englischen »quirks«) genannt, in den Hintergrund.</p>
		<p>Wenn Sie bei solchem Event-Handling schnell zu Resultaten kommen wollen, sei Ihnen die Verwendung einer <a href="bibliotheken.html">JavaScript-Bibliothek</a> empfohlen. Die gängigen Frameworks nehmen Ihnen die Vereinheitlichung beim Event-Handling größtenteils ab.</p>
	</div>
</div>

<div class="section" id="onload">
	<h2>Onload-Techniken &ndash; Scripte ausführen, sobald das Dokument verfügbar ist</h2>
	
	<div class="subsection" id="onload-nachteile">
		<h3>Das <code>load</code>-Ereignis und seine Nachteile</h3>
		<p>Wir haben bereits die <a href="#ereignisbasierung">drei Phasen von ereignisbasierten Scripten</a> kennengelernt, die ohne ins HTML eingebettetes JavaScript auskommen (Unobtrusive JavaScript). Die zweite Phase tritt ein, wenn das Dokument fertig geladen ist und ein Script Zugriff auf den Elementenbaum des Dokuments hat. Dieser Zugriff ist nötig, um bei den gewünschten Elementen Event-Handler zu registrieren.</p>
		<p>Wir haben das dokumentweite <code>load</code>-Ereignis (<code>window.onload</code>) kennengelernt, um eine Funktion zu diesem Zeitpunkt auszuführen. Das <code>load</code>-Ereignis tritt jedoch erst dann ein, wenn das gesamte Dokument samt aller Bilder, Plugins, Iframes und sonstigen externen Ressourcen geladen ist. Je nachdem, wieviele Bilder eingebunden werden, kann zu diesem Zeitpunkt das Dokument schon längst im Browser aufgebaut sein und der Anwender kann es schon größtenteils lesen und bedienen.</p>
		<p>Für das Event-Handling interessiert uns nicht, ob auch alle Bilder fertig geladen, sondern lediglich der JavaScript-Zugriff auf den DOM-Baum, der weit vor dem Eintreten des <code>load</code>-Ereignisses möglich ist (dieser Zustand wird auch »DOM ready« genannt). Bestenfalls sollte das JavaScript die notwendigen Änderungen am Dokument schnellstmöglich vornehmen sowie ihm Interaktivität hinzufügen. Dadurch ist das Dokument eingeschlossen der JavaScript-Funktionalität bereits während des Ladens für den Anwender bedienbar.</p>
	</div>
	
	<div class="subsection" id="domcontentloaded">
		<h3>DOMContentLoaded</h3>
		<p>Lange Rede, kurzer Sinn: Der <code>load</code>-Event ist aus heutiger Sicht für Unobtrusive JavaScript nicht geeignet. Glücklicherweise gibt es ein Ereignis, das eintritt, sobald der Parser den HTML-Code eingelesen hat und der DOM-Baum für JavaScripte nutzbar ist: <code>DOMContentLoaded</code>.</p>
		<p>Die Überwachung dieses Ereignises ist allerdings nur im Zusammenhang mit <code>addEventListener</code>, also dem W3C-Modell möglich. Alle großen Browser, die den DOM-Standard umsetzen, kennen mittlerweile auch <code>DOMContentLoaded</code>. Eine Ausnahme bildet der Internet Explorer einschließlich der neusten Version 8: Weder unterstützt er den DOM-Standard, noch kennt er das Ereignis <code>DOMContentLoaded</code>.</p>
		<p>Das folgende Beispiel demonstriert die Überwachung der beiden Ereignisse <code>load</code> und <code>DOMContentLoaded</code>:</p>
<pre>function dokumentGeladen (e) {
	alert("Das Ereignis " + e.type + " ist passiert.")
}
document.addEventListener("load", dokumentGeladen, false);
document.addEventListener("DOMContentLoaded", dokumentGeladen, false);</pre>
		<p>Aus den besagten Gründen kann der Internet Explorer dieses Beispiel ausführen, er kennt die Methode <code>addEventListener</code> nicht.</p>
		<p>Das Beispiel zeigt, dass der <code>DOMContentLoaded</code>-Event vor dem <code>load</code>-Event passiert. Wenn große und zahlreiche externen Ressourcen in das Dokument eingebunden sind, dann kann zwischen beiden Ereignissen viel Zeit vergehen &ndash; wertvolle Zeit, die ein Script nicht untätig verstreichen lassen sollte.</p>
	</div>
	
	<div class="subsection" id="domcontentloaded-crossbrowser">
		<h3>Browserübergreifendes <code>DOMContentLoaded</code></h3>
		<p>Leider unterstützt der Internet Explorer das äußerst nützliche <code>DOMContentLoaded</code>-Ereignis noch nicht &ndash; ebenso wie ältere Version der Browser Firefox, Safari und Opera.</p>
		<p>Der Internet Explorer kennt kein gleichwertiges Ereignis. Daher nutzt die verbreitete IE-Sonderlösung verschiedene Microsoft-eigene Techniken, um Rückschlüsse darauf zu ziehen, ob der Elementenbaum bereits vollständig eingelesen wurde. Die genaue Funktionsweise sei hier nicht näher erklärt. Stattdessen sei auf eine browserübergreifende Fertiglösung hingewiesen, die sowohl <code>DOMContentLoaded</code> unterstützt als auch einen erprobten Internet-Explorer-Workaround enthält: <a href="http://javascript.nwbox.com/ContentLoaded/contentloaded.js">ContentLoaded.js von Diego Perini</a>. Das Script ist abwärtskompatibel, das heißt, wenn alle Stricke reißen, wird auf das robuste <code>load</code>-Ereignis zurückgefallen.</p>
		<p>Wenn Sie dieses Script einbinden, können Sie eine Funktion folgendermaßen ausführen lassen, sobald der DOM-Baum zur Verfügung steht:</p>
		<pre>function init () {
   // Diese Funktion kann auf den gesamten DOM-Baum zugreifen.
}
// Nutzung von Diego Perinis Helferfunktion
ContentLoaded(window, init);</pre>
		<p>Ein solches oder ähnliches Script ist in den verbreiteten <a href="bibliotheken.html">JavaScript-Frameworks</a> bereits eingebaut. Diese bringen eigene Event-Handling-Systeme mit sich, die das Ausführen von Funktionen erlauben, sobald die DOM-Schnittstelle vollständig nutzbar ist.</p>
	</div>
	
	<div class="subsection" id="domcontentloaded-nachteile">
		<h3>Unklarheiten bei <code>DOMContentLoaded</code></h3>
		<p>Das <code>DOMContentLoaded</code>-Ereignis ist eine Technik, die ein Browserhersteller [Mozilla?] erfunden hat und die die anderen Browserhersteller übernommen haben, weil sie sie nützlich fanden. Das heißt, das Ereignis wurde noch nicht formal spezfiziert und seine genaue Funktionsweise noch nicht standardisiert. Das führt dazu, dass sich die Browser im Detail unterschiedlich verhalten.</p>
		<p>Eine Unstimmigkeit ist die Frage, ob das Ereignis durch den Ladevorgang externer Stylesheets verzögert werden soll.</p>
		<p>Beide Varianten ergeben Sinn: Es reicht zwar aus, dass der DOM-Baum komplett eingelesen ist, wenn man Event-Handler registrieren will. Allerdings gibt es auch Scripte, die in der Initialisierungsphase bereits auf die Darstellung gewisser Elemente reagieren sollen &ndash; und diese wird üblicherweise durch externe Stylesheets geregelt. Wenn das Script beispielsweise die Größe eines Elements in Erfahrung bringen will, muss der Browser bereits die Stylesheets verarbeitet und die Darstellung berechnet haben.</p>
		<p>Seien Sie also vorsichtig, wenn Sie <code>DOMContentLoaded</code> nutzen und Ihre Scripte Informationen über die Darstellung der Elemente abfragen. Große JavaScript-Frameworks nehmen eine Vereinheitlichung vor: Sie verwenden nicht allein <code>DOMContentLoaded</code>, sondern prüfen zusätzlich, ob alle eingebundenen Stylesheets bereits geladen wurden. Wenn der Ladevorgang noch andauert, wird die Prüfung nach einer Zeit wiederholt und erst dann die angegebenen Handler-Funktionen ausgeführt. Somit ist garantiert, dass alle Style-Informationen auf das Dokument angewendet wurden, bevor sich die zweite Phase der Scripte anläuft.</p>
	</div>
	
</div>

<div class="section" id="delegation">
	<h2>Effizientes Event-Handling: Event-Delegation</h2>
	<p>Wenn zahlreiche Elemente im Dokument überwacht werden sollen, ist es sehr aufwändig umzusetzen und langsam in der Ausführung, diese herauszusuchen, zu durchlaufen und bei jedem denselben Event-Handler zu registrieren. Bei solchen Aufgabenstellungen lässt sich der Bubbling-Effekt dafür nutzen, die Ereignisse bei verschiedenen Elementen bei einem gemeinsamen höherliegenden zu verarbeiten. Diese Technik nennt sich <dfn>Event-Delegation</dfn>, was soviel bedeutet, dass einem anderen Element die Aufgabe übertragen wird, das Ereignis zu verarbeiten.</p>
	<p>Event-Delegation eignet sich insbesondere dann, wenn viele gleichförmige Elemente in Menüs, Link-Listen, Formularen oder Tabellen JavaScript-Interaktivität benötigen, man aber nicht jedes Element einzeln ansprechen will.</p>
	<p>Nehmen wir beispielsweise eine Liste mit Links zu Bildern. Wenn JavaScript aktiv ist, soll das Vollbild dokumentintern eingeblendet werden. Ein ähnliches Beispiel hatten wir bereits beim Unterdrücken der Standardaktion &ndash; die Umsetzung der Einblendung bleibt weiterhin ausgeklammert.</p>
	<p>Wir gehen von folgendem HTML-Gerüst aus:</p>
	<pre>
&lt;ul id="bilderliste"&gt;
&lt;li&gt;&lt;a href="bilder/bild1.jpg"&gt;&lt;img src="bilder/thumbnail1.jpg" alt=""&gt;
   Ebru und Robin auf dem Empire State Building&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="bilder/bild2.jpg"&gt;&lt;img src="bilder/thumbnail2.jpg" alt=""&gt;
   Noël und Francis vor dem Taj Mahal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="bilder/bild3.jpg"&gt;&lt;img src="bilder/thumbnail3.jpg" alt=""&gt;
   Isaak und Ahmet vor den Pyramiden von Gizeh&lt;/a&gt;&lt;/li&gt;
&lt;!-- ... viele weitere Links mit Thumbnails ... --&gt;
&lt;/ul&gt;
</pre>
	<p>Beim Klick auf einen der Links soll nun das verlinkte Bild eingeblendet werden. Anstatt jedem <code>a</code>-Element einzeln einen Handler zuzuweisen, registrieren wir ihn beim gemeinsamen Vorfahrenelement <code>ul</code> mit der ID <code>bilderliste</code>:</p>
	<pre>document.getElementById("bilderliste").onclick = bilderlistenKlick;</pre>
	<p>In der angegebenen Handler-Funktion <code>bilderlistenKlick</code> findet nun die Überprüfung des Zielelementes statt.</p>
	<pre>funktion bilderlistenKlick (e) {
   // Vereinheitlichung von Event-Objekt und Zielelement
   var e = e || window.event;
   var target = e.target || e.srcElement;
   
   var elementName = target.nodeName,
      aElement = false;
   // Überprüfe, ob das Zielelement ein Link oder ein Bild im Link ist:
   if (elementName == "A") {
      // Falls ein Link geklickt wurde, speichere das Zielelement
      // in der Variable aElement:
      aElement = target;
   } else if (elementName == "IMG") {
      // Falls das Thumbnail-Bild geklickt wurde,
      // suche das zugehörige Link-Element:
      aElement = target.parentNode;
   }
   
   // Zeige das Vollbild, wenn das Zielelement
   // ein Link ist oder in einem Link liegt:
   if (aElement) {
      zeigeVollbild(aElement);
      // Unterdrücke die Standardaktion:
      return false;
   }
   
   // Andernfalls mache nichts.
}</pre>
	<p>In dieser Funktion wird das Zielelement des Ereignisses angesprochen und dessen Elementname überprüft. Wenn ein <code>a</code>-Element geklickt wurde, muss es sich um einen Link auf ein Bild handeln und das Vollbild soll eingeblendet werden.</p>
	<p>Das alleine wäre bereits mit der Abfrage <code>if (target.nodeName == "A")</code> zu erledigen. Das Beispiel hat allerdings bewusst eine Schwierigkeit eingebaut, um Ihnen das Event-Bubbling und das Arbeiten mit dem Zielelement näher zu bringen: In den <code>a</code>-Elementen liegen zusätzlich <code>img</code>-Elemente für die Thumbnails. Wenn der Anwender auf diese klickt, soll das Vollbild selbstverständlich ebenfalls eingeblendet werden. In dem Fall ist jedoch nicht der Link das Zielelement, sondern logischerweise das <code>img</code>-Element.</p>
	<p>Aus diesem Grund muss die Abfrage erweitert werden: Handelt es sich um ein <code>a</code>-Element <em>oder</em> um ein Element, das direkt in einem <code>a</code>-Element liegt? Falls ein <code>img</code>-Element das Zielelement ist, steigen wir von diesem zu seinem <code>a</code>-Elternelement auf. Schließlich wird die Funktion <code>zeigeVollbild</code> mit dem gefundenen <code>a</code>-Elementobjekt als Parameter aufgerufen. Das Gerüst dieser Funktion sieht so aus:</p>
<pre>function zeigeVollbild (aElement) {
   // Empfange das Elementobjekt als ersten Parameter und
   // lese dessen href-Attribut mit der Bild-Adresse aus:
   var bildAdresse = aElement.href;
   
   // Blende das Bild ein, auf das der Link zeigt.
   // ... (an dieser Stelle uninteressant) ...
}</pre>
	<p>Dieses Beispiel soll Ihnen die grundlegende Funktionsweise von Event-Delegation veranschaulichen:</p>
	<ol>
		<li>Es gibt eine Handler-Funktion, die alle aufsteigenden Ereignisse eines Types bei seinen Kindelementen überwacht.</li>
		<li>Darin wird das Ereignis untersucht und insbesondere das Zielelement überprüft.</li>
		<li>Wenn das Zielelement gewissen Kriterien entspricht (z.B. einem bestimmten Elementyp oder einer Klasse angehört), wird auf das Ereignis reagiert. Das kann in dieser Funktion erfolgen oder der Übersicht halber in einer anderen.</li>
	</ol>
	<p>Wie Sie schon bei diesem einfachen Beispiel sehen, ist eine aufwändige Untersuchung des DOM-Elementenbaumes rund um das Zielelement nötig. Bei Event-Delegation stellt sich oft die Frage, ob das Zielelement in einem anderen Element enthalten ist, auf das gewisse Kriterien zutreffen. Eine allgemeinere und vielseitig einsetzbare Lösung werden Sie später noch kennenlernen.</p>
</div>

<div class="section" id="capturing">
	<h2>Capturing</h2>
	<p>Capturing (englisch für »Einfangen«) ist eine Phase beim Event-Fluss, die wir bereits kurz angesprochen haben. Der DOM-Event-Standard definiert drei Phasen, in denen ein Ereignis durch den DOM-Elementbaum wandert (Event-Fluss) und Handler auslöst:</p>
	<ol>
		<li><strong>Capturing-Phase</strong> (Absteigen zum Zielelement): Das Ereignis steigt vom obersten Dokument-Knoten im Elementenbaum hinab bis zum Zielelement des Ereignisses. Auf diesem Weg werden alle Handler ausgeführt, die für den Ereignistyp für die Capturing-Phase registriert wurden.
		<li><strong>Target-Phase</strong> (Zielelement-Phase): Das Ereignis erreicht sein Zielelement und löst die betreffenden Handler aus, die dort für die Bubbling-Phase registriert wurden.</li>
		<li><strong>Bubbling-Phase</strong> (Aufsteigen vom Zielelement) : Das Ereignis steigt ausgehend vom Zielelement wieder in der Element-Hierarchie auf. Es durchläuft alle Vorfahrenelemente und löst dort die relevanten Handler aus.</li>
	</ol>
	<p>Wie wir uns das Bubbling zunutze machen, haben wir bereits bei der <a href="#delegation">Event-Delegation</a> kennengelernt. Mithilfe des Capturings lassen sich ähnliche Effekte erzielen: Wir können ein Event-Handler bei einem höherliegenden Element registrieren, um die Ereignisse zu überwachen, die bei vielen Nachfahrenelemente passieren.</p>
	<p>Der Unterschied ist folgender: Nicht alle Ereignisse haben eine Bubbling-Phase, das heißt nicht alle Ereignisse steigen auf und lösen die entsprechenden Handler bei ihren Vorfahrenelementen aus. Das hat zwar durchaus seinen Sinn, macht aber die beschriebene Event-Delegation unmöglich. Gäbe es das Event-Capturing nicht, wären Sie gezwungen, alle nicht aufsteigenden Ereignisse direkt bei ihren Zielelementen zu überwachen. Mithilfe des Event-Capturings können Sie auch solche Ereignisse zentral überwachen &ndash; denn jedes Ereignis hat eine Capturing-Phase.</p>
	<p>Event-Capturing ist nur unter Verwendung der standardisierten Methode <code>addEventListener</code> möglich. Das traditionelle Event-Handling mit seinem Schema <code>element.onevent = handlerfunktion</code> registriert den Handler immer für die Bubbling-Phase. Dasselbe gilt für das Microsoft-Modell mit <code>attachEvent</code>. Da <code>addEventListener</code> noch nicht vom Internet Explorer unterstützt wird, ist eine Nutzung in browserübergreifenden Scripten nur möglich, wenn für den Internet Explorer eine Alternative ohne Event-Capturing bereitgestellt wird.</p>
	<p>Um Event-Handler für die Capturing-Phase zu registrieren, nutzen Sie wie gewohnt <code>addEventListener</code>, setzen jedoch den dritten Boolean-Parameter auf <code>true</code>:</p>
	<pre>document.addEventListener("focus", captureHandler, true);</pre>
	<p>Die Vorteile des Capturings liegen also darin, insbesondere nicht aufsteigende Ereignisse bei einem höherliegenden Element zu verarbeiten.
	Folgende Ereignisse steigen beispielsweise nicht auf:
	<p>load, z.B. bei Bildern, Objekten und Iframes
	<p>focus und blur
	<p>mouseenter und mouseleave
	<p>submit
	<p>	Und man kann den Event-Fluss abbrechen, indem man das Ereignis schon in der Capturing-Phase »abfängt«. Target- und Bubbling-Phase fallen dann aus. Das Ereignis erreicht das Zielelement nie.
	<p>Wie? Mit stopPropagation
	</p>
</div>

</body>
</html>